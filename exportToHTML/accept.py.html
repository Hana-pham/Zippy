<html>
<head>
<title>accept.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
accept.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">codecs</span>
<span class="s0">import </span><span class="s1">re</span>

<span class="s0">from </span><span class="s1">.structures </span><span class="s0">import </span><span class="s1">ImmutableList</span>


<span class="s0">class </span><span class="s1">Accept(ImmutableList):</span>
    <span class="s2">&quot;&quot;&quot;An :class:`Accept` object is just a list subclass for lists of 
    ``(value, quality)`` tuples.  It is automatically sorted by specificity 
    and quality. 
 
    All :class:`Accept` objects work similar to a list but provide extra 
    functionality for working with the data.  Containment checks are 
    normalized to the rules of that header: 
 
    &gt;&gt;&gt; a = CharsetAccept([('ISO-8859-1', 1), ('utf-8', 0.7)]) 
    &gt;&gt;&gt; a.best 
    'ISO-8859-1' 
    &gt;&gt;&gt; 'iso-8859-1' in a 
    True 
    &gt;&gt;&gt; 'UTF8' in a 
    True 
    &gt;&gt;&gt; 'utf7' in a 
    False 
 
    To get the quality for an item you can use normal item lookup: 
 
    &gt;&gt;&gt; print a['utf-8'] 
    0.7 
    &gt;&gt;&gt; a['utf7'] 
    0 
 
    .. versionchanged:: 0.5 
       :class:`Accept` objects are forced immutable now. 
 
    .. versionchanged:: 1.0.0 
       :class:`Accept` internal values are no longer ordered 
       alphabetically for equal quality tags. Instead the initial 
       order is preserved. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">values=()):</span>
        <span class="s0">if </span><span class="s1">values </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">list.__init__(self)</span>
            <span class="s1">self.provided = </span><span class="s0">False</span>
        <span class="s0">elif </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">Accept):</span>
            <span class="s1">self.provided = values.provided</span>
            <span class="s1">list.__init__(self</span><span class="s0">, </span><span class="s1">values)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.provided = </span><span class="s0">True</span>
            <span class="s1">values = sorted(</span>
                <span class="s1">values</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">lambda </span><span class="s1">x: (self._specificity(x[</span><span class="s3">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">x[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">reverse=</span><span class="s0">True</span>
            <span class="s1">)</span>
            <span class="s1">list.__init__(self</span><span class="s0">, </span><span class="s1">values)</span>

    <span class="s0">def </span><span class="s1">_specificity(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s2">&quot;&quot;&quot;Returns a tuple describing the value's specificity.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">(value != </span><span class="s4">&quot;*&quot;</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_value_matches(self</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">item):</span>
        <span class="s2">&quot;&quot;&quot;Check if a value matches a given accept item.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">item == </span><span class="s4">&quot;*&quot; </span><span class="s0">or </span><span class="s1">item.lower() == value.lower()</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s2">&quot;&quot;&quot;Besides index lookup (getting item n) you can also pass it a string 
        to get the quality for the item.  If the item is not in the list, the 
        returned quality is ``0``. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">return </span><span class="s1">self.quality(key)</span>
        <span class="s0">return </span><span class="s1">list.__getitem__(self</span><span class="s0">, </span><span class="s1">key)</span>

    <span class="s0">def </span><span class="s1">quality(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s2">&quot;&quot;&quot;Returns the quality of the key. 
 
        .. versionadded:: 0.6 
           In previous versions you had to use the item-lookup syntax 
           (eg: ``obj[key]`` instead of ``obj.quality(key)``) 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">item</span><span class="s0">, </span><span class="s1">quality </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s0">if </span><span class="s1">self._value_matches(key</span><span class="s0">, </span><span class="s1">item):</span>
                <span class="s0">return </span><span class="s1">quality</span>
        <span class="s0">return </span><span class="s3">0</span>

    <span class="s0">def </span><span class="s1">__contains__(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s0">for </span><span class="s1">item</span><span class="s0">, </span><span class="s1">_quality </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s0">if </span><span class="s1">self._value_matches(value</span><span class="s0">, </span><span class="s1">item):</span>
                <span class="s0">return True</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s1">pairs_str = </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span><span class="s4">f&quot;(</span><span class="s0">{</span><span class="s1">x</span><span class="s0">!r}</span><span class="s4">, </span><span class="s0">{</span><span class="s1">y</span><span class="s0">}</span><span class="s4">)&quot; </span><span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y </span><span class="s0">in </span><span class="s1">self)</span>
        <span class="s0">return </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">}</span><span class="s4">([</span><span class="s0">{</span><span class="s1">pairs_str</span><span class="s0">}</span><span class="s4">])&quot;</span>

    <span class="s0">def </span><span class="s1">index(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s2">&quot;&quot;&quot;Get the position of an entry or raise :exc:`ValueError`. 
 
        :param key: The key to be looked up. 
 
        .. versionchanged:: 0.5 
           This used to raise :exc:`IndexError`, which was inconsistent 
           with the list API. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">for </span><span class="s1">idx</span><span class="s0">, </span><span class="s1">(item</span><span class="s0">, </span><span class="s1">_quality) </span><span class="s0">in </span><span class="s1">enumerate(self):</span>
                <span class="s0">if </span><span class="s1">self._value_matches(key</span><span class="s0">, </span><span class="s1">item):</span>
                    <span class="s0">return </span><span class="s1">idx</span>
            <span class="s0">raise </span><span class="s1">ValueError(key)</span>
        <span class="s0">return </span><span class="s1">list.index(self</span><span class="s0">, </span><span class="s1">key)</span>

    <span class="s0">def </span><span class="s1">find(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s2">&quot;&quot;&quot;Get the position of an entry or return -1. 
 
        :param key: The key to be looked up. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.index(key)</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s0">return </span><span class="s1">-</span><span class="s3">1</span>

    <span class="s0">def </span><span class="s1">values(self):</span>
        <span class="s2">&quot;&quot;&quot;Iterate over all values.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s0">yield </span><span class="s1">item[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">to_header(self):</span>
        <span class="s2">&quot;&quot;&quot;Convert the header set into an HTTP header string.&quot;&quot;&quot;</span>
        <span class="s1">result = []</span>
        <span class="s0">for </span><span class="s1">value</span><span class="s0">, </span><span class="s1">quality </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s0">if </span><span class="s1">quality != </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s1">value = </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">value</span><span class="s0">}</span><span class="s4">;q=</span><span class="s0">{</span><span class="s1">quality</span><span class="s0">}</span><span class="s4">&quot;</span>
            <span class="s1">result.append(value)</span>
        <span class="s0">return </span><span class="s4">&quot;,&quot;</span><span class="s1">.join(result)</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s1">self.to_header()</span>

    <span class="s0">def </span><span class="s1">_best_single_match(self</span><span class="s0">, </span><span class="s1">match):</span>
        <span class="s0">for </span><span class="s1">client_item</span><span class="s0">, </span><span class="s1">quality </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s0">if </span><span class="s1">self._value_matches(match</span><span class="s0">, </span><span class="s1">client_item):</span>
                <span class="s5"># self is sorted by specificity descending, we can exit</span>
                <span class="s0">return </span><span class="s1">client_item</span><span class="s0">, </span><span class="s1">quality</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">best_match(self</span><span class="s0">, </span><span class="s1">matches</span><span class="s0">, </span><span class="s1">default=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Returns the best match from a list of possible matches based 
        on the specificity and quality of the client. If two items have the 
        same quality and specificity, the one is returned that comes first. 
 
        :param matches: a list of matches to check for 
        :param default: the value that is returned if none match 
        &quot;&quot;&quot;</span>
        <span class="s1">result = default</span>
        <span class="s1">best_quality = -</span><span class="s3">1</span>
        <span class="s1">best_specificity = (-</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">server_item </span><span class="s0">in </span><span class="s1">matches:</span>
            <span class="s1">match = self._best_single_match(server_item)</span>
            <span class="s0">if not </span><span class="s1">match:</span>
                <span class="s0">continue</span>
            <span class="s1">client_item</span><span class="s0">, </span><span class="s1">quality = match</span>
            <span class="s1">specificity = self._specificity(client_item)</span>
            <span class="s0">if </span><span class="s1">quality &lt;= </span><span class="s3">0 </span><span class="s0">or </span><span class="s1">quality &lt; best_quality:</span>
                <span class="s0">continue</span>
            <span class="s5"># better quality or same quality but more specific =&gt; better match</span>
            <span class="s0">if </span><span class="s1">quality &gt; best_quality </span><span class="s0">or </span><span class="s1">specificity &gt; best_specificity:</span>
                <span class="s1">result = server_item</span>
                <span class="s1">best_quality = quality</span>
                <span class="s1">best_specificity = specificity</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">best(self):</span>
        <span class="s2">&quot;&quot;&quot;The best match as value.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self:</span>
            <span class="s0">return </span><span class="s1">self[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>


<span class="s1">_mime_split_re = re.compile(</span><span class="s4">r&quot;/|(?:\s*;\s*)&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_normalize_mime(value):</span>
    <span class="s0">return </span><span class="s1">_mime_split_re.split(value.lower())</span>


<span class="s0">class </span><span class="s1">MIMEAccept(Accept):</span>
    <span class="s2">&quot;&quot;&quot;Like :class:`Accept` but with special methods and behavior for 
    mimetypes. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">_specificity(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s0">return </span><span class="s1">tuple(x != </span><span class="s4">&quot;*&quot; </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">_mime_split_re.split(value))</span>

    <span class="s0">def </span><span class="s1">_value_matches(self</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">item):</span>
        <span class="s5"># item comes from the client, can't match if it's invalid.</span>
        <span class="s0">if </span><span class="s4">&quot;/&quot; </span><span class="s0">not in </span><span class="s1">item:</span>
            <span class="s0">return False</span>

        <span class="s5"># value comes from the application, tell the developer when it</span>
        <span class="s5"># doesn't look valid.</span>
        <span class="s0">if </span><span class="s4">&quot;/&quot; </span><span class="s0">not in </span><span class="s1">value:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;invalid mimetype </span><span class="s0">{</span><span class="s1">value</span><span class="s0">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>

        <span class="s5"># Split the match value into type, subtype, and a sorted list of parameters.</span>
        <span class="s1">normalized_value = _normalize_mime(value)</span>
        <span class="s1">value_type</span><span class="s0">, </span><span class="s1">value_subtype = normalized_value[:</span><span class="s3">2</span><span class="s1">]</span>
        <span class="s1">value_params = sorted(normalized_value[</span><span class="s3">2</span><span class="s1">:])</span>

        <span class="s5"># &quot;*/*&quot; is the only valid value that can start with &quot;*&quot;.</span>
        <span class="s0">if </span><span class="s1">value_type == </span><span class="s4">&quot;*&quot; </span><span class="s0">and </span><span class="s1">value_subtype != </span><span class="s4">&quot;*&quot;</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;invalid mimetype </span><span class="s0">{</span><span class="s1">value</span><span class="s0">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>

        <span class="s5"># Split the accept item into type, subtype, and parameters.</span>
        <span class="s1">normalized_item = _normalize_mime(item)</span>
        <span class="s1">item_type</span><span class="s0">, </span><span class="s1">item_subtype = normalized_item[:</span><span class="s3">2</span><span class="s1">]</span>
        <span class="s1">item_params = sorted(normalized_item[</span><span class="s3">2</span><span class="s1">:])</span>

        <span class="s5"># &quot;*/not-*&quot; from the client is invalid, can't match.</span>
        <span class="s0">if </span><span class="s1">item_type == </span><span class="s4">&quot;*&quot; </span><span class="s0">and </span><span class="s1">item_subtype != </span><span class="s4">&quot;*&quot;</span><span class="s1">:</span>
            <span class="s0">return False</span>

        <span class="s0">return </span><span class="s1">(</span>
            <span class="s1">(item_type == </span><span class="s4">&quot;*&quot; </span><span class="s0">and </span><span class="s1">item_subtype == </span><span class="s4">&quot;*&quot;</span><span class="s1">)</span>
            <span class="s0">or </span><span class="s1">(value_type == </span><span class="s4">&quot;*&quot; </span><span class="s0">and </span><span class="s1">value_subtype == </span><span class="s4">&quot;*&quot;</span><span class="s1">)</span>
        <span class="s1">) </span><span class="s0">or </span><span class="s1">(</span>
            <span class="s1">item_type == value_type</span>
            <span class="s0">and </span><span class="s1">(</span>
                <span class="s1">item_subtype == </span><span class="s4">&quot;*&quot;</span>
                <span class="s0">or </span><span class="s1">value_subtype == </span><span class="s4">&quot;*&quot;</span>
                <span class="s0">or </span><span class="s1">(item_subtype == value_subtype </span><span class="s0">and </span><span class="s1">item_params == value_params)</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">accept_html(self):</span>
        <span class="s2">&quot;&quot;&quot;True if this object accepts HTML.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">(</span>
            <span class="s4">&quot;text/html&quot; </span><span class="s0">in </span><span class="s1">self </span><span class="s0">or </span><span class="s4">&quot;application/xhtml+xml&quot; </span><span class="s0">in </span><span class="s1">self </span><span class="s0">or </span><span class="s1">self.accept_xhtml</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">accept_xhtml(self):</span>
        <span class="s2">&quot;&quot;&quot;True if this object accepts XHTML.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s4">&quot;application/xhtml+xml&quot; </span><span class="s0">in </span><span class="s1">self </span><span class="s0">or </span><span class="s4">&quot;application/xml&quot; </span><span class="s0">in </span><span class="s1">self</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">accept_json(self):</span>
        <span class="s2">&quot;&quot;&quot;True if this object accepts JSON.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s4">&quot;application/json&quot; </span><span class="s0">in </span><span class="s1">self</span>


<span class="s1">_locale_delim_re = re.compile(</span><span class="s4">r&quot;[_-]&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_normalize_lang(value):</span>
    <span class="s2">&quot;&quot;&quot;Process a language tag for matching.&quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">_locale_delim_re.split(value.lower())</span>


<span class="s0">class </span><span class="s1">LanguageAccept(Accept):</span>
    <span class="s2">&quot;&quot;&quot;Like :class:`Accept` but with normalization for language tags.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">_value_matches(self</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">item):</span>
        <span class="s0">return </span><span class="s1">item == </span><span class="s4">&quot;*&quot; </span><span class="s0">or </span><span class="s1">_normalize_lang(value) == _normalize_lang(item)</span>

    <span class="s0">def </span><span class="s1">best_match(self</span><span class="s0">, </span><span class="s1">matches</span><span class="s0">, </span><span class="s1">default=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Given a list of supported values, finds the best match from 
        the list of accepted values. 
 
        Language tags are normalized for the purpose of matching, but 
        are returned unchanged. 
 
        If no exact match is found, this will fall back to matching 
        the first subtag (primary language only), first with the 
        accepted values then with the match values. This partial is not 
        applied to any other language subtags. 
 
        The default is returned if no exact or fallback match is found. 
 
        :param matches: A list of supported languages to find a match. 
        :param default: The value that is returned if none match. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Look for an exact match first. If a client accepts &quot;en-US&quot;,</span>
        <span class="s5"># &quot;en-US&quot; is a valid match at this point.</span>
        <span class="s1">result = super().best_match(matches)</span>

        <span class="s0">if </span><span class="s1">result </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">result</span>

        <span class="s5"># Fall back to accepting primary tags. If a client accepts</span>
        <span class="s5"># &quot;en-US&quot;, &quot;en&quot; is a valid match at this point. Need to use</span>
        <span class="s5"># re.split to account for 2 or 3 letter codes.</span>
        <span class="s1">fallback = Accept(</span>
            <span class="s1">[(_locale_delim_re.split(item[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">item[</span><span class="s3">1</span><span class="s1">]) </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">self]</span>
        <span class="s1">)</span>
        <span class="s1">result = fallback.best_match(matches)</span>

        <span class="s0">if </span><span class="s1">result </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">result</span>

        <span class="s5"># Fall back to matching primary tags. If the client accepts</span>
        <span class="s5"># &quot;en&quot;, &quot;en-US&quot; is a valid match at this point.</span>
        <span class="s1">fallback_matches = [_locale_delim_re.split(item</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">matches]</span>
        <span class="s1">result = super().best_match(fallback_matches)</span>

        <span class="s5"># Return a value from the original match list. Find the first</span>
        <span class="s5"># original value that starts with the matched primary tag.</span>
        <span class="s0">if </span><span class="s1">result </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">next(item </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">matches </span><span class="s0">if </span><span class="s1">item.startswith(result))</span>

        <span class="s0">return </span><span class="s1">default</span>


<span class="s0">class </span><span class="s1">CharsetAccept(Accept):</span>
    <span class="s2">&quot;&quot;&quot;Like :class:`Accept` but with normalization for charsets.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">_value_matches(self</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">item):</span>
        <span class="s0">def </span><span class="s1">_normalize(name):</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">codecs.lookup(name).name</span>
            <span class="s0">except </span><span class="s1">LookupError:</span>
                <span class="s0">return </span><span class="s1">name.lower()</span>

        <span class="s0">return </span><span class="s1">item == </span><span class="s4">&quot;*&quot; </span><span class="s0">or </span><span class="s1">_normalize(value) == _normalize(item)</span>
</pre>
</body>
</html>