<html>
<head>
<title>metadata.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
metadata.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">email.feedparser</span>
<span class="s0">import </span><span class="s1">email.header</span>
<span class="s0">import </span><span class="s1">email.message</span>
<span class="s0">import </span><span class="s1">email.parser</span>
<span class="s0">import </span><span class="s1">email.policy</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">typing</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Any</span><span class="s0">,</span>
    <span class="s1">Callable</span><span class="s0">,</span>
    <span class="s1">Dict</span><span class="s0">,</span>
    <span class="s1">Generic</span><span class="s0">,</span>
    <span class="s1">List</span><span class="s0">,</span>
    <span class="s1">Optional</span><span class="s0">,</span>
    <span class="s1">Tuple</span><span class="s0">,</span>
    <span class="s1">Type</span><span class="s0">,</span>
    <span class="s1">Union</span><span class="s0">,</span>
    <span class="s1">cast</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">requirements</span><span class="s0">, </span><span class="s1">specifiers</span><span class="s0">, </span><span class="s1">utils</span><span class="s0">, </span><span class="s1">version </span><span class="s0">as </span><span class="s1">version_module</span>

<span class="s1">T = typing.TypeVar(</span><span class="s2">&quot;T&quot;</span><span class="s1">)</span>
<span class="s0">if </span><span class="s1">sys.version_info[:</span><span class="s3">2</span><span class="s1">] &gt;= (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">8</span><span class="s1">):  </span><span class="s4"># pragma: no cover</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Literal</span><span class="s0">, </span><span class="s1">TypedDict</span>
<span class="s0">else</span><span class="s1">:  </span><span class="s4"># pragma: no cover</span>
    <span class="s0">if </span><span class="s1">typing.TYPE_CHECKING:</span>
        <span class="s0">from </span><span class="s1">typing_extensions </span><span class="s0">import </span><span class="s1">Literal</span><span class="s0">, </span><span class="s1">TypedDict</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">from </span><span class="s1">typing_extensions </span><span class="s0">import </span><span class="s1">Literal</span><span class="s0">, </span><span class="s1">TypedDict</span>
        <span class="s0">except </span><span class="s1">ImportError:</span>

            <span class="s0">class </span><span class="s1">Literal:</span>
                <span class="s0">def </span><span class="s1">__init_subclass__(*_args</span><span class="s0">, </span><span class="s1">**_kwargs):</span>
                    <span class="s0">pass</span>

            <span class="s0">class </span><span class="s1">TypedDict:</span>
                <span class="s0">def </span><span class="s1">__init_subclass__(*_args</span><span class="s0">, </span><span class="s1">**_kwargs):</span>
                    <span class="s0">pass</span>


<span class="s0">try</span><span class="s1">:</span>
    <span class="s1">ExceptionGroup</span>
<span class="s0">except </span><span class="s1">NameError:  </span><span class="s4"># pragma: no cover</span>

    <span class="s0">class </span><span class="s1">ExceptionGroup(Exception):  </span><span class="s4"># noqa: N818</span>
        <span class="s5">&quot;&quot;&quot;A minimal implementation of :external:exc:`ExceptionGroup` from Python 3.11. 
 
        If :external:exc:`ExceptionGroup` is already defined by Python itself, 
        that version is used instead. 
        &quot;&quot;&quot;</span>

        <span class="s1">message: str</span>
        <span class="s1">exceptions: List[Exception]</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">message: str</span><span class="s0">, </span><span class="s1">exceptions: List[Exception]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
            <span class="s1">self.message = message</span>
            <span class="s1">self.exceptions = exceptions</span>

        <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
            <span class="s0">return </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">self.__class__.__name__</span><span class="s0">}</span><span class="s2">(</span><span class="s0">{</span><span class="s1">self.message</span><span class="s0">!r}</span><span class="s2">, </span><span class="s0">{</span><span class="s1">self.exceptions</span><span class="s0">!r}</span><span class="s2">)&quot;</span>

<span class="s0">else</span><span class="s1">:  </span><span class="s4"># pragma: no cover</span>
    <span class="s1">ExceptionGroup = ExceptionGroup</span>


<span class="s0">class </span><span class="s1">InvalidMetadata(ValueError):</span>
    <span class="s5">&quot;&quot;&quot;A metadata field contains invalid data.&quot;&quot;&quot;</span>

    <span class="s1">field: str</span>
    <span class="s2">&quot;&quot;&quot;The name of the field that contains invalid data.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">field: str</span><span class="s0">, </span><span class="s1">message: str) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.field = field</span>
        <span class="s1">super().__init__(message)</span>


<span class="s4"># The RawMetadata class attempts to make as few assumptions about the underlying</span>
<span class="s4"># serialization formats as possible. The idea is that as long as a serialization</span>
<span class="s4"># formats offer some very basic primitives in *some* way then we can support</span>
<span class="s4"># serializing to and from that format.</span>
<span class="s0">class </span><span class="s1">RawMetadata(TypedDict</span><span class="s0">, </span><span class="s1">total=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;A dictionary of raw core metadata. 
 
    Each field in core metadata maps to a key of this dictionary (when data is 
    provided). The key is lower-case and underscores are used instead of dashes 
    compared to the equivalent core metadata field. Any core metadata field that 
    can be specified multiple times or can hold multiple values in a single 
    field have a key with a plural name. See :class:`Metadata` whose attributes 
    match the keys of this dictionary. 
 
    Core metadata fields that can be specified multiple times are stored as a 
    list or dict depending on which is appropriate for the field. Any fields 
    which hold multiple values in a single field are stored as a list. 
 
    &quot;&quot;&quot;</span>

    <span class="s4"># Metadata 1.0 - PEP 241</span>
    <span class="s1">metadata_version: str</span>
    <span class="s1">name: str</span>
    <span class="s1">version: str</span>
    <span class="s1">platforms: List[str]</span>
    <span class="s1">summary: str</span>
    <span class="s1">description: str</span>
    <span class="s1">keywords: List[str]</span>
    <span class="s1">home_page: str</span>
    <span class="s1">author: str</span>
    <span class="s1">author_email: str</span>
    <span class="s1">license: str</span>

    <span class="s4"># Metadata 1.1 - PEP 314</span>
    <span class="s1">supported_platforms: List[str]</span>
    <span class="s1">download_url: str</span>
    <span class="s1">classifiers: List[str]</span>
    <span class="s1">requires: List[str]</span>
    <span class="s1">provides: List[str]</span>
    <span class="s1">obsoletes: List[str]</span>

    <span class="s4"># Metadata 1.2 - PEP 345</span>
    <span class="s1">maintainer: str</span>
    <span class="s1">maintainer_email: str</span>
    <span class="s1">requires_dist: List[str]</span>
    <span class="s1">provides_dist: List[str]</span>
    <span class="s1">obsoletes_dist: List[str]</span>
    <span class="s1">requires_python: str</span>
    <span class="s1">requires_external: List[str]</span>
    <span class="s1">project_urls: Dict[str</span><span class="s0">, </span><span class="s1">str]</span>

    <span class="s4"># Metadata 2.0</span>
    <span class="s4"># PEP 426 attempted to completely revamp the metadata format</span>
    <span class="s4"># but got stuck without ever being able to build consensus on</span>
    <span class="s4"># it and ultimately ended up withdrawn.</span>
    <span class="s4">#</span>
    <span class="s4"># However, a number of tools had started emitting METADATA with</span>
    <span class="s4"># `2.0` Metadata-Version, so for historical reasons, this version</span>
    <span class="s4"># was skipped.</span>

    <span class="s4"># Metadata 2.1 - PEP 566</span>
    <span class="s1">description_content_type: str</span>
    <span class="s1">provides_extra: List[str]</span>

    <span class="s4"># Metadata 2.2 - PEP 643</span>
    <span class="s1">dynamic: List[str]</span>

    <span class="s4"># Metadata 2.3 - PEP 685</span>
    <span class="s4"># No new fields were added in PEP 685, just some edge case were</span>
    <span class="s4"># tightened up to provide better interoptability.</span>


<span class="s1">_STRING_FIELDS = {</span>
    <span class="s2">&quot;author&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;author_email&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;description&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;description_content_type&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;download_url&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;home_page&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;license&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maintainer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maintainer_email&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;metadata_version&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;name&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requires_python&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;summary&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;version&quot;</span><span class="s0">,</span>
<span class="s1">}</span>

<span class="s1">_LIST_FIELDS = {</span>
    <span class="s2">&quot;classifiers&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dynamic&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;obsoletes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;obsoletes_dist&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;platforms&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;provides&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;provides_dist&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;provides_extra&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requires&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requires_dist&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requires_external&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;supported_platforms&quot;</span><span class="s0">,</span>
<span class="s1">}</span>

<span class="s1">_DICT_FIELDS = {</span>
    <span class="s2">&quot;project_urls&quot;</span><span class="s0">,</span>
<span class="s1">}</span>


<span class="s0">def </span><span class="s1">_parse_keywords(data: str) -&gt; List[str]:</span>
    <span class="s5">&quot;&quot;&quot;Split a string of comma-separate keyboards into a list of keywords.&quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">[k.strip() </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">data.split(</span><span class="s2">&quot;,&quot;</span><span class="s1">)]</span>


<span class="s0">def </span><span class="s1">_parse_project_urls(data: List[str]) -&gt; Dict[str</span><span class="s0">, </span><span class="s1">str]:</span>
    <span class="s5">&quot;&quot;&quot;Parse a list of label/URL string pairings separated by a comma.&quot;&quot;&quot;</span>
    <span class="s1">urls = {}</span>
    <span class="s0">for </span><span class="s1">pair </span><span class="s0">in </span><span class="s1">data:</span>
        <span class="s4"># Our logic is slightly tricky here as we want to try and do</span>
        <span class="s4"># *something* reasonable with malformed data.</span>
        <span class="s4">#</span>
        <span class="s4"># The main thing that we have to worry about, is data that does</span>
        <span class="s4"># not have a ',' at all to split the label from the Value. There</span>
        <span class="s4"># isn't a singular right answer here, and we will fail validation</span>
        <span class="s4"># later on (if the caller is validating) so it doesn't *really*</span>
        <span class="s4"># matter, but since the missing value has to be an empty str</span>
        <span class="s4"># and our return value is dict[str, str], if we let the key</span>
        <span class="s4"># be the missing value, then they'd have multiple '' values that</span>
        <span class="s4"># overwrite each other in a accumulating dict.</span>
        <span class="s4">#</span>
        <span class="s4"># The other potentional issue is that it's possible to have the</span>
        <span class="s4"># same label multiple times in the metadata, with no solid &quot;right&quot;</span>
        <span class="s4"># answer with what to do in that case. As such, we'll do the only</span>
        <span class="s4"># thing we can, which is treat the field as unparseable and add it</span>
        <span class="s4"># to our list of unparsed fields.</span>
        <span class="s1">parts = [p.strip() </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">pair.split(</span><span class="s2">&quot;,&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)]</span>
        <span class="s1">parts.extend([</span><span class="s2">&quot;&quot;</span><span class="s1">] * (max(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">- len(parts))))  </span><span class="s4"># Ensure 2 items</span>

        <span class="s4"># TODO: The spec doesn't say anything about if the keys should be</span>
        <span class="s4">#       considered case sensitive or not... logically they should</span>
        <span class="s4">#       be case-preserving and case-insensitive, but doing that</span>
        <span class="s4">#       would open up more cases where we might have duplicate</span>
        <span class="s4">#       entries.</span>
        <span class="s1">label</span><span class="s0">, </span><span class="s1">url = parts</span>
        <span class="s0">if </span><span class="s1">label </span><span class="s0">in </span><span class="s1">urls:</span>
            <span class="s4"># The label already exists in our set of urls, so this field</span>
            <span class="s4"># is unparseable, and we can just add the whole thing to our</span>
            <span class="s4"># unparseable data and stop processing it.</span>
            <span class="s0">raise </span><span class="s1">KeyError(</span><span class="s2">&quot;duplicate labels in project urls&quot;</span><span class="s1">)</span>
        <span class="s1">urls[label] = url</span>

    <span class="s0">return </span><span class="s1">urls</span>


<span class="s0">def </span><span class="s1">_get_payload(msg: email.message.Message</span><span class="s0">, </span><span class="s1">source: Union[bytes</span><span class="s0">, </span><span class="s1">str]) -&gt; str:</span>
    <span class="s5">&quot;&quot;&quot;Get the body of the message.&quot;&quot;&quot;</span>
    <span class="s4"># If our source is a str, then our caller has managed encodings for us,</span>
    <span class="s4"># and we don't need to deal with it.</span>
    <span class="s0">if </span><span class="s1">isinstance(source</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s1">payload: str = msg.get_payload()</span>
        <span class="s0">return </span><span class="s1">payload</span>
    <span class="s4"># If our source is a bytes, then we're managing the encoding and we need</span>
    <span class="s4"># to deal with it.</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">bpayload: bytes = msg.get_payload(decode=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">bpayload.decode(</span><span class="s2">&quot;utf8&quot;</span><span class="s0">, </span><span class="s2">&quot;strict&quot;</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">UnicodeDecodeError:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;payload in an invalid encoding&quot;</span><span class="s1">)</span>


<span class="s4"># The various parse_FORMAT functions here are intended to be as lenient as</span>
<span class="s4"># possible in their parsing, while still returning a correctly typed</span>
<span class="s4"># RawMetadata.</span>
<span class="s4">#</span>
<span class="s4"># To aid in this, we also generally want to do as little touching of the</span>
<span class="s4"># data as possible, except where there are possibly some historic holdovers</span>
<span class="s4"># that make valid data awkward to work with.</span>
<span class="s4">#</span>
<span class="s4"># While this is a lower level, intermediate format than our ``Metadata``</span>
<span class="s4"># class, some light touch ups can make a massive difference in usability.</span>

<span class="s4"># Map METADATA fields to RawMetadata.</span>
<span class="s1">_EMAIL_TO_RAW_MAPPING = {</span>
    <span class="s2">&quot;author&quot;</span><span class="s1">: </span><span class="s2">&quot;author&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;author-email&quot;</span><span class="s1">: </span><span class="s2">&quot;author_email&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;classifier&quot;</span><span class="s1">: </span><span class="s2">&quot;classifiers&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;description&quot;</span><span class="s1">: </span><span class="s2">&quot;description&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;description-content-type&quot;</span><span class="s1">: </span><span class="s2">&quot;description_content_type&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;download-url&quot;</span><span class="s1">: </span><span class="s2">&quot;download_url&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dynamic&quot;</span><span class="s1">: </span><span class="s2">&quot;dynamic&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;home-page&quot;</span><span class="s1">: </span><span class="s2">&quot;home_page&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;keywords&quot;</span><span class="s1">: </span><span class="s2">&quot;keywords&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;license&quot;</span><span class="s1">: </span><span class="s2">&quot;license&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maintainer&quot;</span><span class="s1">: </span><span class="s2">&quot;maintainer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maintainer-email&quot;</span><span class="s1">: </span><span class="s2">&quot;maintainer_email&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;metadata-version&quot;</span><span class="s1">: </span><span class="s2">&quot;metadata_version&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;name&quot;</span><span class="s1">: </span><span class="s2">&quot;name&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;obsoletes&quot;</span><span class="s1">: </span><span class="s2">&quot;obsoletes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;obsoletes-dist&quot;</span><span class="s1">: </span><span class="s2">&quot;obsoletes_dist&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;platform&quot;</span><span class="s1">: </span><span class="s2">&quot;platforms&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;project-url&quot;</span><span class="s1">: </span><span class="s2">&quot;project_urls&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;provides&quot;</span><span class="s1">: </span><span class="s2">&quot;provides&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;provides-dist&quot;</span><span class="s1">: </span><span class="s2">&quot;provides_dist&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;provides-extra&quot;</span><span class="s1">: </span><span class="s2">&quot;provides_extra&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requires&quot;</span><span class="s1">: </span><span class="s2">&quot;requires&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requires-dist&quot;</span><span class="s1">: </span><span class="s2">&quot;requires_dist&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requires-external&quot;</span><span class="s1">: </span><span class="s2">&quot;requires_external&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requires-python&quot;</span><span class="s1">: </span><span class="s2">&quot;requires_python&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;summary&quot;</span><span class="s1">: </span><span class="s2">&quot;summary&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;supported-platform&quot;</span><span class="s1">: </span><span class="s2">&quot;supported_platforms&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;version&quot;</span><span class="s1">: </span><span class="s2">&quot;version&quot;</span><span class="s0">,</span>
<span class="s1">}</span>
<span class="s1">_RAW_TO_EMAIL_MAPPING = {raw: email </span><span class="s0">for </span><span class="s1">email</span><span class="s0">, </span><span class="s1">raw </span><span class="s0">in </span><span class="s1">_EMAIL_TO_RAW_MAPPING.items()}</span>


<span class="s0">def </span><span class="s1">parse_email(data: Union[bytes</span><span class="s0">, </span><span class="s1">str]) -&gt; Tuple[RawMetadata</span><span class="s0">, </span><span class="s1">Dict[str</span><span class="s0">, </span><span class="s1">List[str]]]:</span>
    <span class="s5">&quot;&quot;&quot;Parse a distribution's metadata stored as email headers (e.g. from ``METADATA``). 
 
    This function returns a two-item tuple of dicts. The first dict is of 
    recognized fields from the core metadata specification. Fields that can be 
    parsed and translated into Python's built-in types are converted 
    appropriately. All other fields are left as-is. Fields that are allowed to 
    appear multiple times are stored as lists. 
 
    The second dict contains all other fields from the metadata. This includes 
    any unrecognized fields. It also includes any fields which are expected to 
    be parsed into a built-in type but were not formatted appropriately. Finally, 
    any fields that are expected to appear only once but are repeated are 
    included in this dict. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">raw: Dict[str</span><span class="s0">, </span><span class="s1">Union[str</span><span class="s0">, </span><span class="s1">List[str]</span><span class="s0">, </span><span class="s1">Dict[str</span><span class="s0">, </span><span class="s1">str]]] = {}</span>
    <span class="s1">unparsed: Dict[str</span><span class="s0">, </span><span class="s1">List[str]] = {}</span>

    <span class="s0">if </span><span class="s1">isinstance(data</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s1">parsed = email.parser.Parser(policy=email.policy.compat32).parsestr(data)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">parsed = email.parser.BytesParser(policy=email.policy.compat32).parsebytes(data)</span>

    <span class="s4"># We have to wrap parsed.keys() in a set, because in the case of multiple</span>
    <span class="s4"># values for a key (a list), the key will appear multiple times in the</span>
    <span class="s4"># list of keys, but we're avoiding that by using get_all().</span>
    <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">frozenset(parsed.keys()):</span>
        <span class="s4"># Header names in RFC are case insensitive, so we'll normalize to all</span>
        <span class="s4"># lower case to make comparisons easier.</span>
        <span class="s1">name = name.lower()</span>

        <span class="s4"># We use get_all() here, even for fields that aren't multiple use,</span>
        <span class="s4"># because otherwise someone could have e.g. two Name fields, and we</span>
        <span class="s4"># would just silently ignore it rather than doing something about it.</span>
        <span class="s1">headers = parsed.get_all(name) </span><span class="s0">or </span><span class="s1">[]</span>

        <span class="s4"># The way the email module works when parsing bytes is that it</span>
        <span class="s4"># unconditionally decodes the bytes as ascii using the surrogateescape</span>
        <span class="s4"># handler. When you pull that data back out (such as with get_all() ),</span>
        <span class="s4"># it looks to see if the str has any surrogate escapes, and if it does</span>
        <span class="s4"># it wraps it in a Header object instead of returning the string.</span>
        <span class="s4">#</span>
        <span class="s4"># As such, we'll look for those Header objects, and fix up the encoding.</span>
        <span class="s1">value = []</span>
        <span class="s4"># Flag if we have run into any issues processing the headers, thus</span>
        <span class="s4"># signalling that the data belongs in 'unparsed'.</span>
        <span class="s1">valid_encoding = </span><span class="s0">True</span>
        <span class="s0">for </span><span class="s1">h </span><span class="s0">in </span><span class="s1">headers:</span>
            <span class="s4"># It's unclear if this can return more types than just a Header or</span>
            <span class="s4"># a str, so we'll just assert here to make sure.</span>
            <span class="s0">assert </span><span class="s1">isinstance(h</span><span class="s0">, </span><span class="s1">(email.header.Header</span><span class="s0">, </span><span class="s1">str))</span>

            <span class="s4"># If it's a header object, we need to do our little dance to get</span>
            <span class="s4"># the real data out of it. In cases where there is invalid data</span>
            <span class="s4"># we're going to end up with mojibake, but there's no obvious, good</span>
            <span class="s4"># way around that without reimplementing parts of the Header object</span>
            <span class="s4"># ourselves.</span>
            <span class="s4">#</span>
            <span class="s4"># That should be fine since, if mojibacked happens, this key is</span>
            <span class="s4"># going into the unparsed dict anyways.</span>
            <span class="s0">if </span><span class="s1">isinstance(h</span><span class="s0">, </span><span class="s1">email.header.Header):</span>
                <span class="s4"># The Header object stores it's data as chunks, and each chunk</span>
                <span class="s4"># can be independently encoded, so we'll need to check each</span>
                <span class="s4"># of them.</span>
                <span class="s1">chunks: List[Tuple[bytes</span><span class="s0">, </span><span class="s1">Optional[str]]] = []</span>
                <span class="s0">for </span><span class="s1">bin</span><span class="s0">, </span><span class="s1">encoding </span><span class="s0">in </span><span class="s1">email.header.decode_header(h):</span>
                    <span class="s0">try</span><span class="s1">:</span>
                        <span class="s1">bin.decode(</span><span class="s2">&quot;utf8&quot;</span><span class="s0">, </span><span class="s2">&quot;strict&quot;</span><span class="s1">)</span>
                    <span class="s0">except </span><span class="s1">UnicodeDecodeError:</span>
                        <span class="s4"># Enable mojibake.</span>
                        <span class="s1">encoding = </span><span class="s2">&quot;latin1&quot;</span>
                        <span class="s1">valid_encoding = </span><span class="s0">False</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">encoding = </span><span class="s2">&quot;utf8&quot;</span>
                    <span class="s1">chunks.append((bin</span><span class="s0">, </span><span class="s1">encoding))</span>

                <span class="s4"># Turn our chunks back into a Header object, then let that</span>
                <span class="s4"># Header object do the right thing to turn them into a</span>
                <span class="s4"># string for us.</span>
                <span class="s1">value.append(str(email.header.make_header(chunks)))</span>
            <span class="s4"># This is already a string, so just add it.</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">value.append(h)</span>

        <span class="s4"># We've processed all of our values to get them into a list of str,</span>
        <span class="s4"># but we may have mojibake data, in which case this is an unparsed</span>
        <span class="s4"># field.</span>
        <span class="s0">if not </span><span class="s1">valid_encoding:</span>
            <span class="s1">unparsed[name] = value</span>
            <span class="s0">continue</span>

        <span class="s1">raw_name = _EMAIL_TO_RAW_MAPPING.get(name)</span>
        <span class="s0">if </span><span class="s1">raw_name </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s4"># This is a bit of a weird situation, we've encountered a key that</span>
            <span class="s4"># we don't know what it means, so we don't know whether it's meant</span>
            <span class="s4"># to be a list or not.</span>
            <span class="s4">#</span>
            <span class="s4"># Since we can't really tell one way or another, we'll just leave it</span>
            <span class="s4"># as a list, even though it may be a single item list, because that's</span>
            <span class="s4"># what makes the most sense for email headers.</span>
            <span class="s1">unparsed[name] = value</span>
            <span class="s0">continue</span>

        <span class="s4"># If this is one of our string fields, then we'll check to see if our</span>
        <span class="s4"># value is a list of a single item. If it is then we'll assume that</span>
        <span class="s4"># it was emitted as a single string, and unwrap the str from inside</span>
        <span class="s4"># the list.</span>
        <span class="s4">#</span>
        <span class="s4"># If it's any other kind of data, then we haven't the faintest clue</span>
        <span class="s4"># what we should parse it as, and we have to just add it to our list</span>
        <span class="s4"># of unparsed stuff.</span>
        <span class="s0">if </span><span class="s1">raw_name </span><span class="s0">in </span><span class="s1">_STRING_FIELDS </span><span class="s0">and </span><span class="s1">len(value) == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">raw[raw_name] = value[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s4"># If this is one of our list of string fields, then we can just assign</span>
        <span class="s4"># the value, since email *only* has strings, and our get_all() call</span>
        <span class="s4"># above ensures that this is a list.</span>
        <span class="s0">elif </span><span class="s1">raw_name </span><span class="s0">in </span><span class="s1">_LIST_FIELDS:</span>
            <span class="s1">raw[raw_name] = value</span>
        <span class="s4"># Special Case: Keywords</span>
        <span class="s4"># The keywords field is implemented in the metadata spec as a str,</span>
        <span class="s4"># but it conceptually is a list of strings, and is serialized using</span>
        <span class="s4"># &quot;, &quot;.join(keywords), so we'll do some light data massaging to turn</span>
        <span class="s4"># this into what it logically is.</span>
        <span class="s0">elif </span><span class="s1">raw_name == </span><span class="s2">&quot;keywords&quot; </span><span class="s0">and </span><span class="s1">len(value) == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">raw[raw_name] = _parse_keywords(value[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s4"># Special Case: Project-URL</span>
        <span class="s4"># The project urls is implemented in the metadata spec as a list of</span>
        <span class="s4"># specially-formatted strings that represent a key and a value, which</span>
        <span class="s4"># is fundamentally a mapping, however the email format doesn't support</span>
        <span class="s4"># mappings in a sane way, so it was crammed into a list of strings</span>
        <span class="s4"># instead.</span>
        <span class="s4">#</span>
        <span class="s4"># We will do a little light data massaging to turn this into a map as</span>
        <span class="s4"># it logically should be.</span>
        <span class="s0">elif </span><span class="s1">raw_name == </span><span class="s2">&quot;project_urls&quot;</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">raw[raw_name] = _parse_project_urls(value)</span>
            <span class="s0">except </span><span class="s1">KeyError:</span>
                <span class="s1">unparsed[name] = value</span>
        <span class="s4"># Nothing that we've done has managed to parse this, so it'll just</span>
        <span class="s4"># throw it in our unparseable data and move on.</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">unparsed[name] = value</span>

    <span class="s4"># We need to support getting the Description from the message payload in</span>
    <span class="s4"># addition to getting it from the the headers. This does mean, though, there</span>
    <span class="s4"># is the possibility of it being set both ways, in which case we put both</span>
    <span class="s4"># in 'unparsed' since we don't know which is right.</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">payload = _get_payload(parsed</span><span class="s0">, </span><span class="s1">data)</span>
    <span class="s0">except </span><span class="s1">ValueError:</span>
        <span class="s1">unparsed.setdefault(</span><span class="s2">&quot;description&quot;</span><span class="s0">, </span><span class="s1">[]).append(</span>
            <span class="s1">parsed.get_payload(decode=isinstance(data</span><span class="s0">, </span><span class="s1">bytes))</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">payload:</span>
            <span class="s4"># Check to see if we've already got a description, if so then both</span>
            <span class="s4"># it, and this body move to unparseable.</span>
            <span class="s0">if </span><span class="s2">&quot;description&quot; </span><span class="s0">in </span><span class="s1">raw:</span>
                <span class="s1">description_header = cast(str</span><span class="s0">, </span><span class="s1">raw.pop(</span><span class="s2">&quot;description&quot;</span><span class="s1">))</span>
                <span class="s1">unparsed.setdefault(</span><span class="s2">&quot;description&quot;</span><span class="s0">, </span><span class="s1">[]).extend(</span>
                    <span class="s1">[description_header</span><span class="s0">, </span><span class="s1">payload]</span>
                <span class="s1">)</span>
            <span class="s0">elif </span><span class="s2">&quot;description&quot; </span><span class="s0">in </span><span class="s1">unparsed:</span>
                <span class="s1">unparsed[</span><span class="s2">&quot;description&quot;</span><span class="s1">].append(payload)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">raw[</span><span class="s2">&quot;description&quot;</span><span class="s1">] = payload</span>

    <span class="s4"># We need to cast our `raw` to a metadata, because a TypedDict only support</span>
    <span class="s4"># literal key names, but we're computing our key names on purpose, but the</span>
    <span class="s4"># way this function is implemented, our `TypedDict` can only have valid key</span>
    <span class="s4"># names.</span>
    <span class="s0">return </span><span class="s1">cast(RawMetadata</span><span class="s0">, </span><span class="s1">raw)</span><span class="s0">, </span><span class="s1">unparsed</span>


<span class="s1">_NOT_FOUND = object()</span>


<span class="s4"># Keep the two values in sync.</span>
<span class="s1">_VALID_METADATA_VERSIONS = [</span><span class="s2">&quot;1.0&quot;</span><span class="s0">, </span><span class="s2">&quot;1.1&quot;</span><span class="s0">, </span><span class="s2">&quot;1.2&quot;</span><span class="s0">, </span><span class="s2">&quot;2.1&quot;</span><span class="s0">, </span><span class="s2">&quot;2.2&quot;</span><span class="s0">, </span><span class="s2">&quot;2.3&quot;</span><span class="s1">]</span>
<span class="s1">_MetadataVersion = Literal[</span><span class="s2">&quot;1.0&quot;</span><span class="s0">, </span><span class="s2">&quot;1.1&quot;</span><span class="s0">, </span><span class="s2">&quot;1.2&quot;</span><span class="s0">, </span><span class="s2">&quot;2.1&quot;</span><span class="s0">, </span><span class="s2">&quot;2.2&quot;</span><span class="s0">, </span><span class="s2">&quot;2.3&quot;</span><span class="s1">]</span>

<span class="s1">_REQUIRED_ATTRS = frozenset([</span><span class="s2">&quot;metadata_version&quot;</span><span class="s0">, </span><span class="s2">&quot;name&quot;</span><span class="s0">, </span><span class="s2">&quot;version&quot;</span><span class="s1">])</span>


<span class="s0">class </span><span class="s1">_Validator(Generic[T]):</span>
    <span class="s5">&quot;&quot;&quot;Validate a metadata field. 
 
    All _process_*() methods correspond to a core metadata field. The method is 
    called with the field's raw value. If the raw value is valid it is returned 
    in its &quot;enriched&quot; form (e.g. ``version.Version`` for the ``Version`` field). 
    If the raw value is invalid, :exc:`InvalidMetadata` is raised (with a cause 
    as appropriate). 
    &quot;&quot;&quot;</span>

    <span class="s1">name: str</span>
    <span class="s1">raw_name: str</span>
    <span class="s1">added: _MetadataVersion</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">added: _MetadataVersion = </span><span class="s2">&quot;1.0&quot;</span><span class="s0">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.added = added</span>

    <span class="s0">def </span><span class="s1">__set_name__(self</span><span class="s0">, </span><span class="s1">_owner: </span><span class="s2">&quot;Metadata&quot;</span><span class="s0">, </span><span class="s1">name: str) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.raw_name = _RAW_TO_EMAIL_MAPPING[name]</span>

    <span class="s0">def </span><span class="s1">__get__(self</span><span class="s0">, </span><span class="s1">instance: </span><span class="s2">&quot;Metadata&quot;</span><span class="s0">, </span><span class="s1">_owner: Type[</span><span class="s2">&quot;Metadata&quot;</span><span class="s1">]) -&gt; T:</span>
        <span class="s4"># With Python 3.8, the caching can be replaced with functools.cached_property().</span>
        <span class="s4"># No need to check the cache as attribute lookup will resolve into the</span>
        <span class="s4"># instance's __dict__ before __get__ is called.</span>
        <span class="s1">cache = instance.__dict__</span>
        <span class="s1">value = instance._raw.get(self.name)</span>

        <span class="s4"># To make the _process_* methods easier, we'll check if the value is None</span>
        <span class="s4"># and if this field is NOT a required attribute, and if both of those</span>
        <span class="s4"># things are true, we'll skip the the converter. This will mean that the</span>
        <span class="s4"># converters never have to deal with the None union.</span>
        <span class="s0">if </span><span class="s1">self.name </span><span class="s0">in </span><span class="s1">_REQUIRED_ATTRS </span><span class="s0">or </span><span class="s1">value </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">converter: Callable[[Any]</span><span class="s0">, </span><span class="s1">T] = getattr(self</span><span class="s0">, </span><span class="s2">f&quot;_process_</span><span class="s0">{</span><span class="s1">self.name</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>
            <span class="s0">except </span><span class="s1">AttributeError:</span>
                <span class="s0">pass</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">value = converter(value)</span>

        <span class="s1">cache[self.name] = value</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">del </span><span class="s1">instance._raw[self.name]  </span><span class="s4"># type: ignore[misc]</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">pass</span>

        <span class="s0">return </span><span class="s1">cast(T</span><span class="s0">, </span><span class="s1">value)</span>

    <span class="s0">def </span><span class="s1">_invalid_metadata(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">msg: str</span><span class="s0">, </span><span class="s1">cause: Optional[Exception] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; InvalidMetadata:</span>
        <span class="s1">exc = InvalidMetadata(</span>
            <span class="s1">self.raw_name</span><span class="s0">, </span><span class="s1">msg.format_map({</span><span class="s2">&quot;field&quot;</span><span class="s1">: repr(self.raw_name)})</span>
        <span class="s1">)</span>
        <span class="s1">exc.__cause__ = cause</span>
        <span class="s0">return </span><span class="s1">exc</span>

    <span class="s0">def </span><span class="s1">_process_metadata_version(self</span><span class="s0">, </span><span class="s1">value: str) -&gt; _MetadataVersion:</span>
        <span class="s4"># Implicitly makes Metadata-Version required.</span>
        <span class="s0">if </span><span class="s1">value </span><span class="s0">not in </span><span class="s1">_VALID_METADATA_VERSIONS:</span>
            <span class="s0">raise </span><span class="s1">self._invalid_metadata(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">value</span><span class="s0">!r} </span><span class="s2">is not a valid metadata version&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">cast(_MetadataVersion</span><span class="s0">, </span><span class="s1">value)</span>

    <span class="s0">def </span><span class="s1">_process_name(self</span><span class="s0">, </span><span class="s1">value: str) -&gt; str:</span>
        <span class="s0">if not </span><span class="s1">value:</span>
            <span class="s0">raise </span><span class="s1">self._invalid_metadata(</span><span class="s2">&quot;{field} is a required field&quot;</span><span class="s1">)</span>
        <span class="s4"># Validate the name as a side-effect.</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">utils.canonicalize_name(value</span><span class="s0">, </span><span class="s1">validate=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">utils.InvalidName </span><span class="s0">as </span><span class="s1">exc:</span>
            <span class="s0">raise </span><span class="s1">self._invalid_metadata(</span>
                <span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">value</span><span class="s0">!r} </span><span class="s2">is invalid for </span><span class="s0">{{</span><span class="s2">field</span><span class="s0">}}</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s1">cause=exc</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">value</span>

    <span class="s0">def </span><span class="s1">_process_version(self</span><span class="s0">, </span><span class="s1">value: str) -&gt; version_module.Version:</span>
        <span class="s0">if not </span><span class="s1">value:</span>
            <span class="s0">raise </span><span class="s1">self._invalid_metadata(</span><span class="s2">&quot;{field} is a required field&quot;</span><span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">version_module.parse(value)</span>
        <span class="s0">except </span><span class="s1">version_module.InvalidVersion </span><span class="s0">as </span><span class="s1">exc:</span>
            <span class="s0">raise </span><span class="s1">self._invalid_metadata(</span>
                <span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">value</span><span class="s0">!r} </span><span class="s2">is invalid for </span><span class="s0">{{</span><span class="s2">field</span><span class="s0">}}</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s1">cause=exc</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_process_summary(self</span><span class="s0">, </span><span class="s1">value: str) -&gt; str:</span>
        <span class="s5">&quot;&quot;&quot;Check the field contains no newlines.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot; </span><span class="s0">in </span><span class="s1">value:</span>
            <span class="s0">raise </span><span class="s1">self._invalid_metadata(</span><span class="s2">&quot;{field} must be a single line&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">value</span>

    <span class="s0">def </span><span class="s1">_process_description_content_type(self</span><span class="s0">, </span><span class="s1">value: str) -&gt; str:</span>
        <span class="s1">content_types = {</span><span class="s2">&quot;text/plain&quot;</span><span class="s0">, </span><span class="s2">&quot;text/x-rst&quot;</span><span class="s0">, </span><span class="s2">&quot;text/markdown&quot;</span><span class="s1">}</span>
        <span class="s1">message = email.message.EmailMessage()</span>
        <span class="s1">message[</span><span class="s2">&quot;content-type&quot;</span><span class="s1">] = value</span>

        <span class="s1">content_type</span><span class="s0">, </span><span class="s1">parameters = (</span>
            <span class="s4"># Defaults to `text/plain` if parsing failed.</span>
            <span class="s1">message.get_content_type().lower()</span><span class="s0">,</span>
            <span class="s1">message[</span><span class="s2">&quot;content-type&quot;</span><span class="s1">].params</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s4"># Check if content-type is valid or defaulted to `text/plain` and thus was</span>
        <span class="s4"># not parseable.</span>
        <span class="s0">if </span><span class="s1">content_type </span><span class="s0">not in </span><span class="s1">content_types </span><span class="s0">or </span><span class="s1">content_type </span><span class="s0">not in </span><span class="s1">value.lower():</span>
            <span class="s0">raise </span><span class="s1">self._invalid_metadata(</span>
                <span class="s2">f&quot;</span><span class="s0">{{</span><span class="s2">field</span><span class="s0">}} </span><span class="s2">must be one of </span><span class="s0">{</span><span class="s1">list(content_types)</span><span class="s0">}</span><span class="s2">, not </span><span class="s0">{</span><span class="s1">value</span><span class="s0">!r}</span><span class="s2">&quot;</span>
            <span class="s1">)</span>

        <span class="s1">charset = parameters.get(</span><span class="s2">&quot;charset&quot;</span><span class="s0">, </span><span class="s2">&quot;UTF-8&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">charset != </span><span class="s2">&quot;UTF-8&quot;</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">self._invalid_metadata(</span>
                <span class="s2">f&quot;</span><span class="s0">{{</span><span class="s2">field</span><span class="s0">}} </span><span class="s2">can only specify the UTF-8 charset, not </span><span class="s0">{</span><span class="s1">list(charset)</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">)</span>

        <span class="s1">markdown_variants = {</span><span class="s2">&quot;GFM&quot;</span><span class="s0">, </span><span class="s2">&quot;CommonMark&quot;</span><span class="s1">}</span>
        <span class="s1">variant = parameters.get(</span><span class="s2">&quot;variant&quot;</span><span class="s0">, </span><span class="s2">&quot;GFM&quot;</span><span class="s1">)  </span><span class="s4"># Use an acceptable default.</span>
        <span class="s0">if </span><span class="s1">content_type == </span><span class="s2">&quot;text/markdown&quot; </span><span class="s0">and </span><span class="s1">variant </span><span class="s0">not in </span><span class="s1">markdown_variants:</span>
            <span class="s0">raise </span><span class="s1">self._invalid_metadata(</span>
                <span class="s2">f&quot;valid Markdown variants for </span><span class="s0">{{</span><span class="s2">field</span><span class="s0">}} </span><span class="s2">are </span><span class="s0">{</span><span class="s1">list(markdown_variants)</span><span class="s0">}</span><span class="s2">, &quot;</span>
                <span class="s2">f&quot;not </span><span class="s0">{</span><span class="s1">variant</span><span class="s0">!r}</span><span class="s2">&quot;</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">value</span>

    <span class="s0">def </span><span class="s1">_process_dynamic(self</span><span class="s0">, </span><span class="s1">value: List[str]) -&gt; List[str]:</span>
        <span class="s0">for </span><span class="s1">dynamic_field </span><span class="s0">in </span><span class="s1">map(str.lower</span><span class="s0">, </span><span class="s1">value):</span>
            <span class="s0">if </span><span class="s1">dynamic_field </span><span class="s0">in </span><span class="s1">{</span><span class="s2">&quot;name&quot;</span><span class="s0">, </span><span class="s2">&quot;version&quot;</span><span class="s0">, </span><span class="s2">&quot;metadata-version&quot;</span><span class="s1">}:</span>
                <span class="s0">raise </span><span class="s1">self._invalid_metadata(</span>
                    <span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">value</span><span class="s0">!r} </span><span class="s2">is not allowed as a dynamic field&quot;</span>
                <span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">dynamic_field </span><span class="s0">not in </span><span class="s1">_EMAIL_TO_RAW_MAPPING:</span>
                <span class="s0">raise </span><span class="s1">self._invalid_metadata(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">value</span><span class="s0">!r} </span><span class="s2">is not a valid dynamic field&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">list(map(str.lower</span><span class="s0">, </span><span class="s1">value))</span>

    <span class="s0">def </span><span class="s1">_process_provides_extra(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">value: List[str]</span><span class="s0">,</span>
    <span class="s1">) -&gt; List[utils.NormalizedName]:</span>
        <span class="s1">normalized_names = []</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">value:</span>
                <span class="s1">normalized_names.append(utils.canonicalize_name(name</span><span class="s0">, </span><span class="s1">validate=</span><span class="s0">True</span><span class="s1">))</span>
        <span class="s0">except </span><span class="s1">utils.InvalidName </span><span class="s0">as </span><span class="s1">exc:</span>
            <span class="s0">raise </span><span class="s1">self._invalid_metadata(</span>
                <span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">name</span><span class="s0">!r} </span><span class="s2">is invalid for </span><span class="s0">{{</span><span class="s2">field</span><span class="s0">}}</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s1">cause=exc</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">normalized_names</span>

    <span class="s0">def </span><span class="s1">_process_requires_python(self</span><span class="s0">, </span><span class="s1">value: str) -&gt; specifiers.SpecifierSet:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">specifiers.SpecifierSet(value)</span>
        <span class="s0">except </span><span class="s1">specifiers.InvalidSpecifier </span><span class="s0">as </span><span class="s1">exc:</span>
            <span class="s0">raise </span><span class="s1">self._invalid_metadata(</span>
                <span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">value</span><span class="s0">!r} </span><span class="s2">is invalid for </span><span class="s0">{{</span><span class="s2">field</span><span class="s0">}}</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s1">cause=exc</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_process_requires_dist(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">value: List[str]</span><span class="s0">,</span>
    <span class="s1">) -&gt; List[requirements.Requirement]:</span>
        <span class="s1">reqs = []</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">req </span><span class="s0">in </span><span class="s1">value:</span>
                <span class="s1">reqs.append(requirements.Requirement(req))</span>
        <span class="s0">except </span><span class="s1">requirements.InvalidRequirement </span><span class="s0">as </span><span class="s1">exc:</span>
            <span class="s0">raise </span><span class="s1">self._invalid_metadata(</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">req</span><span class="s0">!r} </span><span class="s2">is invalid for </span><span class="s0">{{</span><span class="s2">field</span><span class="s0">}}</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s1">cause=exc)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">reqs</span>


<span class="s0">class </span><span class="s1">Metadata:</span>
    <span class="s5">&quot;&quot;&quot;Representation of distribution metadata. 
 
    Compared to :class:`RawMetadata`, this class provides objects representing 
    metadata fields instead of only using built-in types. Any invalid metadata 
    will cause :exc:`InvalidMetadata` to be raised (with a 
    :py:attr:`~BaseException.__cause__` attribute as appropriate). 
    &quot;&quot;&quot;</span>

    <span class="s1">_raw: RawMetadata</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_raw(cls</span><span class="s0">, </span><span class="s1">data: RawMetadata</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">validate: bool = </span><span class="s0">True</span><span class="s1">) -&gt; </span><span class="s2">&quot;Metadata&quot;</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Create an instance from :class:`RawMetadata`. 
 
        If *validate* is true, all metadata will be validated. All exceptions 
        related to validation will be gathered and raised as an :class:`ExceptionGroup`. 
        &quot;&quot;&quot;</span>
        <span class="s1">ins = cls()</span>
        <span class="s1">ins._raw = data.copy()  </span><span class="s4"># Mutations occur due to caching enriched values.</span>

        <span class="s0">if </span><span class="s1">validate:</span>
            <span class="s1">exceptions: List[Exception] = []</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">metadata_version = ins.metadata_version</span>
                <span class="s1">metadata_age = _VALID_METADATA_VERSIONS.index(metadata_version)</span>
            <span class="s0">except </span><span class="s1">InvalidMetadata </span><span class="s0">as </span><span class="s1">metadata_version_exc:</span>
                <span class="s1">exceptions.append(metadata_version_exc)</span>
                <span class="s1">metadata_version = </span><span class="s0">None</span>

            <span class="s4"># Make sure to check for the fields that are present, the required</span>
            <span class="s4"># fields (so their absence can be reported).</span>
            <span class="s1">fields_to_check = frozenset(ins._raw) | _REQUIRED_ATTRS</span>
            <span class="s4"># Remove fields that have already been checked.</span>
            <span class="s1">fields_to_check -= {</span><span class="s2">&quot;metadata_version&quot;</span><span class="s1">}</span>

            <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">fields_to_check:</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s0">if </span><span class="s1">metadata_version:</span>
                        <span class="s4"># Can't use getattr() as that triggers descriptor protocol which</span>
                        <span class="s4"># will fail due to no value for the instance argument.</span>
                        <span class="s0">try</span><span class="s1">:</span>
                            <span class="s1">field_metadata_version = cls.__dict__[key].added</span>
                        <span class="s0">except </span><span class="s1">KeyError:</span>
                            <span class="s1">exc = InvalidMetadata(key</span><span class="s0">, </span><span class="s2">f&quot;unrecognized field: </span><span class="s0">{</span><span class="s1">key</span><span class="s0">!r}</span><span class="s2">&quot;</span><span class="s1">)</span>
                            <span class="s1">exceptions.append(exc)</span>
                            <span class="s0">continue</span>
                        <span class="s1">field_age = _VALID_METADATA_VERSIONS.index(</span>
                            <span class="s1">field_metadata_version</span>
                        <span class="s1">)</span>
                        <span class="s0">if </span><span class="s1">field_age &gt; metadata_age:</span>
                            <span class="s1">field = _RAW_TO_EMAIL_MAPPING[key]</span>
                            <span class="s1">exc = InvalidMetadata(</span>
                                <span class="s1">field</span><span class="s0">,</span>
                                <span class="s2">&quot;{field} introduced in metadata version &quot;</span>
                                <span class="s2">&quot;{field_metadata_version}, not {metadata_version}&quot;</span><span class="s0">,</span>
                            <span class="s1">)</span>
                            <span class="s1">exceptions.append(exc)</span>
                            <span class="s0">continue</span>
                    <span class="s1">getattr(ins</span><span class="s0">, </span><span class="s1">key)</span>
                <span class="s0">except </span><span class="s1">InvalidMetadata </span><span class="s0">as </span><span class="s1">exc:</span>
                    <span class="s1">exceptions.append(exc)</span>

            <span class="s0">if </span><span class="s1">exceptions:</span>
                <span class="s0">raise </span><span class="s1">ExceptionGroup(</span><span class="s2">&quot;invalid metadata&quot;</span><span class="s0">, </span><span class="s1">exceptions)</span>

        <span class="s0">return </span><span class="s1">ins</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_email(</span>
        <span class="s1">cls</span><span class="s0">, </span><span class="s1">data: Union[bytes</span><span class="s0">, </span><span class="s1">str]</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">validate: bool = </span><span class="s0">True</span>
    <span class="s1">) -&gt; </span><span class="s2">&quot;Metadata&quot;</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Parse metadata from email headers. 
 
        If *validate* is true, the metadata will be validated. All exceptions 
        related to validation will be gathered and raised as an :class:`ExceptionGroup`. 
        &quot;&quot;&quot;</span>
        <span class="s1">raw</span><span class="s0">, </span><span class="s1">unparsed = parse_email(data)</span>

        <span class="s0">if </span><span class="s1">validate:</span>
            <span class="s1">exceptions: list[Exception] = []</span>
            <span class="s0">for </span><span class="s1">unparsed_key </span><span class="s0">in </span><span class="s1">unparsed:</span>
                <span class="s0">if </span><span class="s1">unparsed_key </span><span class="s0">in </span><span class="s1">_EMAIL_TO_RAW_MAPPING:</span>
                    <span class="s1">message = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">unparsed_key</span><span class="s0">!r} </span><span class="s2">has invalid data&quot;</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">message = </span><span class="s2">f&quot;unrecognized field: </span><span class="s0">{</span><span class="s1">unparsed_key</span><span class="s0">!r}</span><span class="s2">&quot;</span>
                <span class="s1">exceptions.append(InvalidMetadata(unparsed_key</span><span class="s0">, </span><span class="s1">message))</span>

            <span class="s0">if </span><span class="s1">exceptions:</span>
                <span class="s0">raise </span><span class="s1">ExceptionGroup(</span><span class="s2">&quot;unparsed&quot;</span><span class="s0">, </span><span class="s1">exceptions)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">cls.from_raw(raw</span><span class="s0">, </span><span class="s1">validate=validate)</span>
        <span class="s0">except </span><span class="s1">ExceptionGroup </span><span class="s0">as </span><span class="s1">exc_group:</span>
            <span class="s0">raise </span><span class="s1">ExceptionGroup(</span>
                <span class="s2">&quot;invalid or unparsed metadata&quot;</span><span class="s0">, </span><span class="s1">exc_group.exceptions</span>
            <span class="s1">) </span><span class="s0">from None</span>

    <span class="s1">metadata_version: _Validator[_MetadataVersion] = _Validator()</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-metadata-version` 
    (required; validated to be a valid metadata version)&quot;&quot;&quot;</span>
    <span class="s1">name: _Validator[str] = _Validator()</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-name` 
    (required; validated using :func:`~packaging.utils.canonicalize_name` and its 
    *validate* parameter)&quot;&quot;&quot;</span>
    <span class="s1">version: _Validator[version_module.Version] = _Validator()</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-version` (required)&quot;&quot;&quot;</span>
    <span class="s1">dynamic: _Validator[Optional[List[str]]] = _Validator(</span>
        <span class="s1">added=</span><span class="s2">&quot;2.2&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-dynamic` 
    (validated against core metadata field names and lowercased)&quot;&quot;&quot;</span>
    <span class="s1">platforms: _Validator[Optional[List[str]]] = _Validator()</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-platform`&quot;&quot;&quot;</span>
    <span class="s1">supported_platforms: _Validator[Optional[List[str]]] = _Validator(added=</span><span class="s2">&quot;1.1&quot;</span><span class="s1">)</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-supported-platform`&quot;&quot;&quot;</span>
    <span class="s1">summary: _Validator[Optional[str]] = _Validator()</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-summary` (validated to contain no newlines)&quot;&quot;&quot;</span>
    <span class="s1">description: _Validator[Optional[str]] = _Validator()  </span><span class="s4"># TODO 2.1: can be in body</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-description`&quot;&quot;&quot;</span>
    <span class="s1">description_content_type: _Validator[Optional[str]] = _Validator(added=</span><span class="s2">&quot;2.1&quot;</span><span class="s1">)</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-description-content-type` (validated)&quot;&quot;&quot;</span>
    <span class="s1">keywords: _Validator[Optional[List[str]]] = _Validator()</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-keywords`&quot;&quot;&quot;</span>
    <span class="s1">home_page: _Validator[Optional[str]] = _Validator()</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-home-page`&quot;&quot;&quot;</span>
    <span class="s1">download_url: _Validator[Optional[str]] = _Validator(added=</span><span class="s2">&quot;1.1&quot;</span><span class="s1">)</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-download-url`&quot;&quot;&quot;</span>
    <span class="s1">author: _Validator[Optional[str]] = _Validator()</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-author`&quot;&quot;&quot;</span>
    <span class="s1">author_email: _Validator[Optional[str]] = _Validator()</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-author-email`&quot;&quot;&quot;</span>
    <span class="s1">maintainer: _Validator[Optional[str]] = _Validator(added=</span><span class="s2">&quot;1.2&quot;</span><span class="s1">)</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-maintainer`&quot;&quot;&quot;</span>
    <span class="s1">maintainer_email: _Validator[Optional[str]] = _Validator(added=</span><span class="s2">&quot;1.2&quot;</span><span class="s1">)</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-maintainer-email`&quot;&quot;&quot;</span>
    <span class="s1">license: _Validator[Optional[str]] = _Validator()</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-license`&quot;&quot;&quot;</span>
    <span class="s1">classifiers: _Validator[Optional[List[str]]] = _Validator(added=</span><span class="s2">&quot;1.1&quot;</span><span class="s1">)</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-classifier`&quot;&quot;&quot;</span>
    <span class="s1">requires_dist: _Validator[Optional[List[requirements.Requirement]]] = _Validator(</span>
        <span class="s1">added=</span><span class="s2">&quot;1.2&quot;</span>
    <span class="s1">)</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-requires-dist`&quot;&quot;&quot;</span>
    <span class="s1">requires_python: _Validator[Optional[specifiers.SpecifierSet]] = _Validator(</span>
        <span class="s1">added=</span><span class="s2">&quot;1.2&quot;</span>
    <span class="s1">)</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-requires-python`&quot;&quot;&quot;</span>
    <span class="s4"># Because `Requires-External` allows for non-PEP 440 version specifiers, we</span>
    <span class="s4"># don't do any processing on the values.</span>
    <span class="s1">requires_external: _Validator[Optional[List[str]]] = _Validator(added=</span><span class="s2">&quot;1.2&quot;</span><span class="s1">)</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-requires-external`&quot;&quot;&quot;</span>
    <span class="s1">project_urls: _Validator[Optional[Dict[str</span><span class="s0">, </span><span class="s1">str]]] = _Validator(added=</span><span class="s2">&quot;1.2&quot;</span><span class="s1">)</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-project-url`&quot;&quot;&quot;</span>
    <span class="s4"># PEP 685 lets us raise an error if an extra doesn't pass `Name` validation</span>
    <span class="s4"># regardless of metadata version.</span>
    <span class="s1">provides_extra: _Validator[Optional[List[utils.NormalizedName]]] = _Validator(</span>
        <span class="s1">added=</span><span class="s2">&quot;2.1&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-provides-extra`&quot;&quot;&quot;</span>
    <span class="s1">provides_dist: _Validator[Optional[List[str]]] = _Validator(added=</span><span class="s2">&quot;1.2&quot;</span><span class="s1">)</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-provides-dist`&quot;&quot;&quot;</span>
    <span class="s1">obsoletes_dist: _Validator[Optional[List[str]]] = _Validator(added=</span><span class="s2">&quot;1.2&quot;</span><span class="s1">)</span>
    <span class="s2">&quot;&quot;&quot;:external:ref:`core-metadata-obsoletes-dist`&quot;&quot;&quot;</span>
    <span class="s1">requires: _Validator[Optional[List[str]]] = _Validator(added=</span><span class="s2">&quot;1.1&quot;</span><span class="s1">)</span>
    <span class="s2">&quot;&quot;&quot;``Requires`` (deprecated)&quot;&quot;&quot;</span>
    <span class="s1">provides: _Validator[Optional[List[str]]] = _Validator(added=</span><span class="s2">&quot;1.1&quot;</span><span class="s1">)</span>
    <span class="s2">&quot;&quot;&quot;``Provides`` (deprecated)&quot;&quot;&quot;</span>
    <span class="s1">obsoletes: _Validator[Optional[List[str]]] = _Validator(added=</span><span class="s2">&quot;1.1&quot;</span><span class="s1">)</span>
    <span class="s2">&quot;&quot;&quot;``Obsoletes`` (deprecated)&quot;&quot;&quot;</span>
</pre>
</body>
</html>