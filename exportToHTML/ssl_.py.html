<html>
<head>
<title>ssl_.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ssl_.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">hmac</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">socket</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">typing</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">binascii </span><span class="s0">import </span><span class="s1">unhexlify</span>
<span class="s0">from </span><span class="s1">hashlib </span><span class="s0">import </span><span class="s1">md5</span><span class="s0">, </span><span class="s1">sha1</span><span class="s0">, </span><span class="s1">sha256</span>

<span class="s0">from </span><span class="s1">..exceptions </span><span class="s0">import </span><span class="s1">ProxySchemeUnsupported</span><span class="s0">, </span><span class="s1">SSLError</span>
<span class="s0">from </span><span class="s1">.url </span><span class="s0">import </span><span class="s1">_BRACELESS_IPV6_ADDRZ_RE</span><span class="s0">, </span><span class="s1">_IPV4_RE</span>

<span class="s1">SSLContext = </span><span class="s0">None</span>
<span class="s1">SSLTransport = </span><span class="s0">None</span>
<span class="s1">HAS_NEVER_CHECK_COMMON_NAME = </span><span class="s0">False</span>
<span class="s1">IS_PYOPENSSL = </span><span class="s0">False</span>
<span class="s1">ALPN_PROTOCOLS = [</span><span class="s2">&quot;http/1.1&quot;</span><span class="s1">]</span>

<span class="s1">_TYPE_VERSION_INFO = typing.Tuple[int</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s1">str</span><span class="s0">, </span><span class="s1">int]</span>

<span class="s3"># Maps the length of a digest to a possible hash function producing this digest</span>
<span class="s1">HASHFUNC_MAP = {</span><span class="s4">32</span><span class="s1">: md5</span><span class="s0">, </span><span class="s4">40</span><span class="s1">: sha1</span><span class="s0">, </span><span class="s4">64</span><span class="s1">: sha256}</span>


<span class="s0">def </span><span class="s1">_is_bpo_43522_fixed(</span>
    <span class="s1">implementation_name: str</span><span class="s0">,</span>
    <span class="s1">version_info: _TYPE_VERSION_INFO</span><span class="s0">,</span>
    <span class="s1">pypy_version_info: _TYPE_VERSION_INFO | </span><span class="s0">None,</span>
<span class="s1">) -&gt; bool:</span>
    <span class="s5">&quot;&quot;&quot;Return True for CPython 3.8.9+, 3.9.3+ or 3.10+ and PyPy 7.3.8+ where 
    setting SSLContext.hostname_checks_common_name to False works. 
 
    Outside of CPython and PyPy we don't know which implementations work 
    or not so we conservatively use our hostname matching as we know that works 
    on all implementations. 
 
    https://github.com/urllib3/urllib3/issues/2192#issuecomment-821832963 
    https://foss.heptapod.net/pypy/pypy/-/issues/3539 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">implementation_name == </span><span class="s2">&quot;pypy&quot;</span><span class="s1">:</span>
        <span class="s3"># https://foss.heptapod.net/pypy/pypy/-/issues/3129</span>
        <span class="s0">return </span><span class="s1">pypy_version_info &gt;= (</span><span class="s4">7</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">8</span><span class="s1">)  </span><span class="s3"># type: ignore[operator]</span>
    <span class="s0">elif </span><span class="s1">implementation_name == </span><span class="s2">&quot;cpython&quot;</span><span class="s1">:</span>
        <span class="s1">major_minor = version_info[:</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">micro = version_info[</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">(</span>
            <span class="s1">(major_minor == (</span><span class="s4">3</span><span class="s0">, </span><span class="s4">8</span><span class="s1">) </span><span class="s0">and </span><span class="s1">micro &gt;= </span><span class="s4">9</span><span class="s1">)</span>
            <span class="s0">or </span><span class="s1">(major_minor == (</span><span class="s4">3</span><span class="s0">, </span><span class="s4">9</span><span class="s1">) </span><span class="s0">and </span><span class="s1">micro &gt;= </span><span class="s4">3</span><span class="s1">)</span>
            <span class="s0">or </span><span class="s1">major_minor &gt;= (</span><span class="s4">3</span><span class="s0">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:  </span><span class="s3"># Defensive:</span>
        <span class="s0">return False</span>


<span class="s0">def </span><span class="s1">_is_has_never_check_common_name_reliable(</span>
    <span class="s1">openssl_version: str</span><span class="s0">,</span>
    <span class="s1">openssl_version_number: int</span><span class="s0">,</span>
    <span class="s1">implementation_name: str</span><span class="s0">,</span>
    <span class="s1">version_info: _TYPE_VERSION_INFO</span><span class="s0">,</span>
    <span class="s1">pypy_version_info: _TYPE_VERSION_INFO | </span><span class="s0">None,</span>
<span class="s1">) -&gt; bool:</span>
    <span class="s3"># As of May 2023, all released versions of LibreSSL fail to reject certificates with</span>
    <span class="s3"># only common names, see https://github.com/urllib3/urllib3/pull/3024</span>
    <span class="s1">is_openssl = openssl_version.startswith(</span><span class="s2">&quot;OpenSSL &quot;</span><span class="s1">)</span>
    <span class="s3"># Before fixing OpenSSL issue #14579, the SSL_new() API was not copying hostflags</span>
    <span class="s3"># like X509_CHECK_FLAG_NEVER_CHECK_SUBJECT, which tripped up CPython.</span>
    <span class="s3"># https://github.com/openssl/openssl/issues/14579</span>
    <span class="s3"># This was released in OpenSSL 1.1.1l+ (&gt;=0x101010cf)</span>
    <span class="s1">is_openssl_issue_14579_fixed = openssl_version_number &gt;= </span><span class="s4">0x101010CF</span>

    <span class="s0">return </span><span class="s1">is_openssl </span><span class="s0">and </span><span class="s1">(</span>
        <span class="s1">is_openssl_issue_14579_fixed</span>
        <span class="s0">or </span><span class="s1">_is_bpo_43522_fixed(implementation_name</span><span class="s0">, </span><span class="s1">version_info</span><span class="s0">, </span><span class="s1">pypy_version_info)</span>
    <span class="s1">)</span>


<span class="s0">if </span><span class="s1">typing.TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">ssl </span><span class="s0">import </span><span class="s1">VerifyMode</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Literal</span><span class="s0">, </span><span class="s1">TypedDict</span>

    <span class="s0">from </span><span class="s1">.ssltransport </span><span class="s0">import </span><span class="s1">SSLTransport </span><span class="s0">as </span><span class="s1">SSLTransportType</span>

    <span class="s0">class </span><span class="s1">_TYPE_PEER_CERT_RET_DICT(TypedDict</span><span class="s0">, </span><span class="s1">total=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s1">subjectAltName: tuple[tuple[str</span><span class="s0">, </span><span class="s1">str]</span><span class="s0">, </span><span class="s1">...]</span>
        <span class="s1">subject: tuple[tuple[tuple[str</span><span class="s0">, </span><span class="s1">str]</span><span class="s0">, </span><span class="s1">...]</span><span class="s0">, </span><span class="s1">...]</span>
        <span class="s1">serialNumber: str</span>


<span class="s3"># Mapping from 'ssl.PROTOCOL_TLSX' to 'TLSVersion.X'</span>
<span class="s1">_SSL_VERSION_TO_TLS_VERSION: dict[int</span><span class="s0">, </span><span class="s1">int] = {}</span>

<span class="s0">try</span><span class="s1">:  </span><span class="s3"># Do we have ssl at all?</span>
    <span class="s0">import </span><span class="s1">ssl</span>
    <span class="s0">from </span><span class="s1">ssl </span><span class="s0">import </span><span class="s1">(  </span><span class="s3"># type: ignore[assignment]</span>
        <span class="s1">CERT_REQUIRED</span><span class="s0">,</span>
        <span class="s1">HAS_NEVER_CHECK_COMMON_NAME</span><span class="s0">,</span>
        <span class="s1">OP_NO_COMPRESSION</span><span class="s0">,</span>
        <span class="s1">OP_NO_TICKET</span><span class="s0">,</span>
        <span class="s1">OPENSSL_VERSION</span><span class="s0">,</span>
        <span class="s1">OPENSSL_VERSION_NUMBER</span><span class="s0">,</span>
        <span class="s1">PROTOCOL_TLS</span><span class="s0">,</span>
        <span class="s1">PROTOCOL_TLS_CLIENT</span><span class="s0">,</span>
        <span class="s1">OP_NO_SSLv2</span><span class="s0">,</span>
        <span class="s1">OP_NO_SSLv3</span><span class="s0">,</span>
        <span class="s1">SSLContext</span><span class="s0">,</span>
        <span class="s1">TLSVersion</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">PROTOCOL_SSLv23 = PROTOCOL_TLS</span>

    <span class="s3"># Setting SSLContext.hostname_checks_common_name = False didn't work before CPython</span>
    <span class="s3"># 3.8.9, 3.9.3, and 3.10 (but OK on PyPy) or OpenSSL 1.1.1l+</span>
    <span class="s0">if </span><span class="s1">HAS_NEVER_CHECK_COMMON_NAME </span><span class="s0">and not </span><span class="s1">_is_has_never_check_common_name_reliable(</span>
        <span class="s1">OPENSSL_VERSION</span><span class="s0">,</span>
        <span class="s1">OPENSSL_VERSION_NUMBER</span><span class="s0">,</span>
        <span class="s1">sys.implementation.name</span><span class="s0">,</span>
        <span class="s1">sys.version_info</span><span class="s0">,</span>
        <span class="s1">sys.pypy_version_info </span><span class="s0">if </span><span class="s1">sys.implementation.name == </span><span class="s2">&quot;pypy&quot; </span><span class="s0">else None,  </span><span class="s3"># type: ignore[attr-defined]</span>
    <span class="s1">):</span>
        <span class="s1">HAS_NEVER_CHECK_COMMON_NAME = </span><span class="s0">False</span>

    <span class="s3"># Need to be careful here in case old TLS versions get</span>
    <span class="s3"># removed in future 'ssl' module implementations.</span>
    <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;TLSv1&quot;</span><span class="s0">, </span><span class="s2">&quot;TLSv1_1&quot;</span><span class="s0">, </span><span class="s2">&quot;TLSv1_2&quot;</span><span class="s1">):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">_SSL_VERSION_TO_TLS_VERSION[getattr(ssl</span><span class="s0">, </span><span class="s2">f&quot;PROTOCOL_</span><span class="s0">{</span><span class="s1">attr</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)] = getattr(</span>
                <span class="s1">TLSVersion</span><span class="s0">, </span><span class="s1">attr</span>
            <span class="s1">)</span>
        <span class="s0">except </span><span class="s1">AttributeError:  </span><span class="s3"># Defensive:</span>
            <span class="s0">continue</span>

    <span class="s0">from </span><span class="s1">.ssltransport </span><span class="s0">import </span><span class="s1">SSLTransport  </span><span class="s3"># type: ignore[assignment]</span>
<span class="s0">except </span><span class="s1">ImportError:</span>
    <span class="s1">OP_NO_COMPRESSION = </span><span class="s4">0x20000  </span><span class="s3"># type: ignore[assignment]</span>
    <span class="s1">OP_NO_TICKET = </span><span class="s4">0x4000  </span><span class="s3"># type: ignore[assignment]</span>
    <span class="s1">OP_NO_SSLv2 = </span><span class="s4">0x1000000  </span><span class="s3"># type: ignore[assignment]</span>
    <span class="s1">OP_NO_SSLv3 = </span><span class="s4">0x2000000  </span><span class="s3"># type: ignore[assignment]</span>
    <span class="s1">PROTOCOL_SSLv23 = PROTOCOL_TLS = </span><span class="s4">2  </span><span class="s3"># type: ignore[assignment]</span>
    <span class="s1">PROTOCOL_TLS_CLIENT = </span><span class="s4">16  </span><span class="s3"># type: ignore[assignment]</span>


<span class="s1">_TYPE_PEER_CERT_RET = typing.Union[</span><span class="s2">&quot;_TYPE_PEER_CERT_RET_DICT&quot;</span><span class="s0">, </span><span class="s1">bytes</span><span class="s0">, None</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">assert_fingerprint(cert: bytes | </span><span class="s0">None, </span><span class="s1">fingerprint: str) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Checks if given fingerprint matches the supplied certificate. 
 
    :param cert: 
        Certificate as bytes object. 
    :param fingerprint: 
        Fingerprint as string of hexdigits, can be interspersed by colons. 
    &quot;&quot;&quot;</span>

    <span class="s0">if </span><span class="s1">cert </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">SSLError(</span><span class="s2">&quot;No certificate for the peer.&quot;</span><span class="s1">)</span>

    <span class="s1">fingerprint = fingerprint.replace(</span><span class="s2">&quot;:&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">).lower()</span>
    <span class="s1">digest_length = len(fingerprint)</span>
    <span class="s1">hashfunc = HASHFUNC_MAP.get(digest_length)</span>
    <span class="s0">if not </span><span class="s1">hashfunc:</span>
        <span class="s0">raise </span><span class="s1">SSLError(</span><span class="s2">f&quot;Fingerprint of invalid length: </span><span class="s0">{</span><span class="s1">fingerprint</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s3"># We need encode() here for py32; works on py2 and p33.</span>
    <span class="s1">fingerprint_bytes = unhexlify(fingerprint.encode())</span>

    <span class="s1">cert_digest = hashfunc(cert).digest()</span>

    <span class="s0">if not </span><span class="s1">hmac.compare_digest(cert_digest</span><span class="s0">, </span><span class="s1">fingerprint_bytes):</span>
        <span class="s0">raise </span><span class="s1">SSLError(</span>
            <span class="s2">f'Fingerprints did not match. Expected &quot;</span><span class="s0">{</span><span class="s1">fingerprint</span><span class="s0">}</span><span class="s2">&quot;, got &quot;</span><span class="s0">{</span><span class="s1">cert_digest.hex()</span><span class="s0">}</span><span class="s2">&quot;'</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">resolve_cert_reqs(candidate: </span><span class="s0">None </span><span class="s1">| int | str) -&gt; VerifyMode:</span>
    <span class="s5">&quot;&quot;&quot; 
    Resolves the argument to a numeric constant, which can be passed to 
    the wrap_socket function/method from the ssl module. 
    Defaults to :data:`ssl.CERT_REQUIRED`. 
    If given a string it is assumed to be the name of the constant in the 
    :mod:`ssl` module or its abbreviation. 
    (So you can specify `REQUIRED` instead of `CERT_REQUIRED`. 
    If it's neither `None` nor a string we assume it is already the numeric 
    constant which can directly be passed to wrap_socket. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">candidate </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">CERT_REQUIRED</span>

    <span class="s0">if </span><span class="s1">isinstance(candidate</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s1">res = getattr(ssl</span><span class="s0">, </span><span class="s1">candidate</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">res </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">res = getattr(ssl</span><span class="s0">, </span><span class="s2">&quot;CERT_&quot; </span><span class="s1">+ candidate)</span>
        <span class="s0">return </span><span class="s1">res  </span><span class="s3"># type: ignore[no-any-return]</span>

    <span class="s0">return </span><span class="s1">candidate  </span><span class="s3"># type: ignore[return-value]</span>


<span class="s0">def </span><span class="s1">resolve_ssl_version(candidate: </span><span class="s0">None </span><span class="s1">| int | str) -&gt; int:</span>
    <span class="s5">&quot;&quot;&quot; 
    like resolve_cert_reqs 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">candidate </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">PROTOCOL_TLS</span>

    <span class="s0">if </span><span class="s1">isinstance(candidate</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s1">res = getattr(ssl</span><span class="s0">, </span><span class="s1">candidate</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">res </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">res = getattr(ssl</span><span class="s0">, </span><span class="s2">&quot;PROTOCOL_&quot; </span><span class="s1">+ candidate)</span>
        <span class="s0">return </span><span class="s1">typing.cast(int</span><span class="s0">, </span><span class="s1">res)</span>

    <span class="s0">return </span><span class="s1">candidate</span>


<span class="s0">def </span><span class="s1">create_urllib3_context(</span>
    <span class="s1">ssl_version: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">cert_reqs: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">options: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">ciphers: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">ssl_minimum_version: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">ssl_maximum_version: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
<span class="s1">) -&gt; ssl.SSLContext:</span>
    <span class="s5">&quot;&quot;&quot;Creates and configures an :class:`ssl.SSLContext` instance for use with urllib3. 
 
    :param ssl_version: 
        The desired protocol version to use. This will default to 
        PROTOCOL_SSLv23 which will negotiate the highest protocol that both 
        the server and your installation of OpenSSL support. 
 
        This parameter is deprecated instead use 'ssl_minimum_version'. 
    :param ssl_minimum_version: 
        The minimum version of TLS to be used. Use the 'ssl.TLSVersion' enum for specifying the value. 
    :param ssl_maximum_version: 
        The maximum version of TLS to be used. Use the 'ssl.TLSVersion' enum for specifying the value. 
        Not recommended to set to anything other than 'ssl.TLSVersion.MAXIMUM_SUPPORTED' which is the 
        default value. 
    :param cert_reqs: 
        Whether to require the certificate verification. This defaults to 
        ``ssl.CERT_REQUIRED``. 
    :param options: 
        Specific OpenSSL options. These default to ``ssl.OP_NO_SSLv2``, 
        ``ssl.OP_NO_SSLv3``, ``ssl.OP_NO_COMPRESSION``, and ``ssl.OP_NO_TICKET``. 
    :param ciphers: 
        Which cipher suites to allow the server to select. Defaults to either system configured 
        ciphers if OpenSSL 1.1.1+, otherwise uses a secure default set of ciphers. 
    :returns: 
        Constructed SSLContext object with specified options 
    :rtype: SSLContext 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">SSLContext </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Can't create an SSLContext object without an ssl module&quot;</span><span class="s1">)</span>

    <span class="s3"># This means 'ssl_version' was specified as an exact value.</span>
    <span class="s0">if </span><span class="s1">ssl_version </span><span class="s0">not in </span><span class="s1">(</span><span class="s0">None, </span><span class="s1">PROTOCOL_TLS</span><span class="s0">, </span><span class="s1">PROTOCOL_TLS_CLIENT):</span>
        <span class="s3"># Disallow setting 'ssl_version' and 'ssl_minimum|maximum_version'</span>
        <span class="s3"># to avoid conflicts.</span>
        <span class="s0">if </span><span class="s1">ssl_minimum_version </span><span class="s0">is not None or </span><span class="s1">ssl_maximum_version </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;Can't specify both 'ssl_version' and either &quot;</span>
                <span class="s2">&quot;'ssl_minimum_version' or 'ssl_maximum_version'&quot;</span>
            <span class="s1">)</span>

        <span class="s3"># 'ssl_version' is deprecated and will be removed in the future.</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># Use 'ssl_minimum_version' and 'ssl_maximum_version' instead.</span>
            <span class="s1">ssl_minimum_version = _SSL_VERSION_TO_TLS_VERSION.get(</span>
                <span class="s1">ssl_version</span><span class="s0">, </span><span class="s1">TLSVersion.MINIMUM_SUPPORTED</span>
            <span class="s1">)</span>
            <span class="s1">ssl_maximum_version = _SSL_VERSION_TO_TLS_VERSION.get(</span>
                <span class="s1">ssl_version</span><span class="s0">, </span><span class="s1">TLSVersion.MAXIMUM_SUPPORTED</span>
            <span class="s1">)</span>

            <span class="s3"># This warning message is pushing users to use 'ssl_minimum_version'</span>
            <span class="s3"># instead of both min/max. Best practice is to only set the minimum version and</span>
            <span class="s3"># keep the maximum version to be it's default value: 'TLSVersion.MAXIMUM_SUPPORTED'</span>
            <span class="s1">warnings.warn(</span>
                <span class="s2">&quot;'ssl_version' option is deprecated and will be &quot;</span>
                <span class="s2">&quot;removed in urllib3 v2.1.0. Instead use 'ssl_minimum_version'&quot;</span><span class="s0">,</span>
                <span class="s1">category=DeprecationWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=</span><span class="s4">2</span><span class="s0">,</span>
            <span class="s1">)</span>

    <span class="s3"># PROTOCOL_TLS is deprecated in Python 3.10 so we always use PROTOCOL_TLS_CLIENT</span>
    <span class="s1">context = SSLContext(PROTOCOL_TLS_CLIENT)</span>

    <span class="s0">if </span><span class="s1">ssl_minimum_version </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">context.minimum_version = ssl_minimum_version</span>
    <span class="s0">else</span><span class="s1">:  </span><span class="s3"># Python &lt;3.10 defaults to 'MINIMUM_SUPPORTED' so explicitly set TLSv1.2 here</span>
        <span class="s1">context.minimum_version = TLSVersion.TLSv1_2</span>

    <span class="s0">if </span><span class="s1">ssl_maximum_version </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">context.maximum_version = ssl_maximum_version</span>

    <span class="s3"># Unless we're given ciphers defer to either system ciphers in</span>
    <span class="s3"># the case of OpenSSL 1.1.1+ or use our own secure default ciphers.</span>
    <span class="s0">if </span><span class="s1">ciphers:</span>
        <span class="s1">context.set_ciphers(ciphers)</span>

    <span class="s3"># Setting the default here, as we may have no ssl module on import</span>
    <span class="s1">cert_reqs = ssl.CERT_REQUIRED </span><span class="s0">if </span><span class="s1">cert_reqs </span><span class="s0">is None else </span><span class="s1">cert_reqs</span>

    <span class="s0">if </span><span class="s1">options </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">options = </span><span class="s4">0</span>
        <span class="s3"># SSLv2 is easily broken and is considered harmful and dangerous</span>
        <span class="s1">options |= OP_NO_SSLv2</span>
        <span class="s3"># SSLv3 has several problems and is now dangerous</span>
        <span class="s1">options |= OP_NO_SSLv3</span>
        <span class="s3"># Disable compression to prevent CRIME attacks for OpenSSL 1.0+</span>
        <span class="s3"># (issue #309)</span>
        <span class="s1">options |= OP_NO_COMPRESSION</span>
        <span class="s3"># TLSv1.2 only. Unless set explicitly, do not request tickets.</span>
        <span class="s3"># This may save some bandwidth on wire, and although the ticket is encrypted,</span>
        <span class="s3"># there is a risk associated with it being on wire,</span>
        <span class="s3"># if the server is not rotating its ticketing keys properly.</span>
        <span class="s1">options |= OP_NO_TICKET</span>

    <span class="s1">context.options |= options</span>

    <span class="s3"># Enable post-handshake authentication for TLS 1.3, see GH #1634. PHA is</span>
    <span class="s3"># necessary for conditional client cert authentication with TLS 1.3.</span>
    <span class="s3"># The attribute is None for OpenSSL &lt;= 1.1.0 or does not exist when using</span>
    <span class="s3"># an SSLContext created by pyOpenSSL.</span>
    <span class="s0">if </span><span class="s1">getattr(context</span><span class="s0">, </span><span class="s2">&quot;post_handshake_auth&quot;</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">context.post_handshake_auth = </span><span class="s0">True</span>

    <span class="s3"># The order of the below lines setting verify_mode and check_hostname</span>
    <span class="s3"># matter due to safe-guards SSLContext has to prevent an SSLContext with</span>
    <span class="s3"># check_hostname=True, verify_mode=NONE/OPTIONAL.</span>
    <span class="s3"># We always set 'check_hostname=False' for pyOpenSSL so we rely on our own</span>
    <span class="s3"># 'ssl.match_hostname()' implementation.</span>
    <span class="s0">if </span><span class="s1">cert_reqs == ssl.CERT_REQUIRED </span><span class="s0">and not </span><span class="s1">IS_PYOPENSSL:</span>
        <span class="s1">context.verify_mode = cert_reqs</span>
        <span class="s1">context.check_hostname = </span><span class="s0">True</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">context.check_hostname = </span><span class="s0">False</span>
        <span class="s1">context.verify_mode = cert_reqs</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">context.hostname_checks_common_name = </span><span class="s0">False</span>
    <span class="s0">except </span><span class="s1">AttributeError:  </span><span class="s3"># Defensive: for CPython &lt; 3.8.9 and 3.9.3; for PyPy &lt; 7.3.8</span>
        <span class="s0">pass</span>

    <span class="s3"># Enable logging of TLS session keys via defacto standard environment variable</span>
    <span class="s3"># 'SSLKEYLOGFILE', if the feature is available (Python 3.8+). Skip empty values.</span>
    <span class="s0">if </span><span class="s1">hasattr(context</span><span class="s0">, </span><span class="s2">&quot;keylog_filename&quot;</span><span class="s1">):</span>
        <span class="s1">sslkeylogfile = os.environ.get(</span><span class="s2">&quot;SSLKEYLOGFILE&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">sslkeylogfile:</span>
            <span class="s1">context.keylog_filename = sslkeylogfile</span>

    <span class="s0">return </span><span class="s1">context</span>


<span class="s1">@typing.overload</span>
<span class="s0">def </span><span class="s1">ssl_wrap_socket(</span>
    <span class="s1">sock: socket.socket</span><span class="s0">,</span>
    <span class="s1">keyfile: str | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">certfile: str | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">cert_reqs: int | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">ca_certs: str | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">server_hostname: str | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">ssl_version: int | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">ciphers: str | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">ssl_context: ssl.SSLContext | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">ca_cert_dir: str | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">key_password: str | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">ca_cert_data: </span><span class="s0">None </span><span class="s1">| str | bytes = ...</span><span class="s0">,</span>
    <span class="s1">tls_in_tls: Literal[</span><span class="s0">False</span><span class="s1">] = ...</span><span class="s0">,</span>
<span class="s1">) -&gt; ssl.SSLSocket:</span>
    <span class="s1">...</span>


<span class="s1">@typing.overload</span>
<span class="s0">def </span><span class="s1">ssl_wrap_socket(</span>
    <span class="s1">sock: socket.socket</span><span class="s0">,</span>
    <span class="s1">keyfile: str | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">certfile: str | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">cert_reqs: int | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">ca_certs: str | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">server_hostname: str | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">ssl_version: int | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">ciphers: str | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">ssl_context: ssl.SSLContext | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">ca_cert_dir: str | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">key_password: str | </span><span class="s0">None </span><span class="s1">= ...</span><span class="s0">,</span>
    <span class="s1">ca_cert_data: </span><span class="s0">None </span><span class="s1">| str | bytes = ...</span><span class="s0">,</span>
    <span class="s1">tls_in_tls: bool = ...</span><span class="s0">,</span>
<span class="s1">) -&gt; ssl.SSLSocket | SSLTransportType:</span>
    <span class="s1">...</span>


<span class="s0">def </span><span class="s1">ssl_wrap_socket(</span>
    <span class="s1">sock: socket.socket</span><span class="s0">,</span>
    <span class="s1">keyfile: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">certfile: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">cert_reqs: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">ca_certs: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">server_hostname: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">ssl_version: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">ciphers: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">ssl_context: ssl.SSLContext | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">ca_cert_dir: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">key_password: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">ca_cert_data: </span><span class="s0">None </span><span class="s1">| str | bytes = </span><span class="s0">None,</span>
    <span class="s1">tls_in_tls: bool = </span><span class="s0">False,</span>
<span class="s1">) -&gt; ssl.SSLSocket | SSLTransportType:</span>
    <span class="s5">&quot;&quot;&quot; 
    All arguments except for server_hostname, ssl_context, tls_in_tls, ca_cert_data and 
    ca_cert_dir have the same meaning as they do when using 
    :func:`ssl.create_default_context`, :meth:`ssl.SSLContext.load_cert_chain`, 
    :meth:`ssl.SSLContext.set_ciphers` and :meth:`ssl.SSLContext.wrap_socket`. 
 
    :param server_hostname: 
        When SNI is supported, the expected hostname of the certificate 
    :param ssl_context: 
        A pre-made :class:`SSLContext` object. If none is provided, one will 
        be created using :func:`create_urllib3_context`. 
    :param ciphers: 
        A string of ciphers we wish the client to support. 
    :param ca_cert_dir: 
        A directory containing CA certificates in multiple separate files, as 
        supported by OpenSSL's -CApath flag or the capath argument to 
        SSLContext.load_verify_locations(). 
    :param key_password: 
        Optional password if the keyfile is encrypted. 
    :param ca_cert_data: 
        Optional string containing CA certificates in PEM format suitable for 
        passing as the cadata parameter to SSLContext.load_verify_locations() 
    :param tls_in_tls: 
        Use SSLTransport to wrap the existing socket. 
    &quot;&quot;&quot;</span>
    <span class="s1">context = ssl_context</span>
    <span class="s0">if </span><span class="s1">context </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s3"># Note: This branch of code and all the variables in it are only used in tests.</span>
        <span class="s3"># We should consider deprecating and removing this code.</span>
        <span class="s1">context = create_urllib3_context(ssl_version</span><span class="s0">, </span><span class="s1">cert_reqs</span><span class="s0">, </span><span class="s1">ciphers=ciphers)</span>

    <span class="s0">if </span><span class="s1">ca_certs </span><span class="s0">or </span><span class="s1">ca_cert_dir </span><span class="s0">or </span><span class="s1">ca_cert_data:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">context.load_verify_locations(ca_certs</span><span class="s0">, </span><span class="s1">ca_cert_dir</span><span class="s0">, </span><span class="s1">ca_cert_data)</span>
        <span class="s0">except </span><span class="s1">OSError </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s0">raise </span><span class="s1">SSLError(e) </span><span class="s0">from </span><span class="s1">e</span>

    <span class="s0">elif </span><span class="s1">ssl_context </span><span class="s0">is None and </span><span class="s1">hasattr(context</span><span class="s0">, </span><span class="s2">&quot;load_default_certs&quot;</span><span class="s1">):</span>
        <span class="s3"># try to load OS default certs; works well on Windows.</span>
        <span class="s1">context.load_default_certs()</span>

    <span class="s3"># Attempt to detect if we get the goofy behavior of the</span>
    <span class="s3"># keyfile being encrypted and OpenSSL asking for the</span>
    <span class="s3"># passphrase via the terminal and instead error out.</span>
    <span class="s0">if </span><span class="s1">keyfile </span><span class="s0">and </span><span class="s1">key_password </span><span class="s0">is None and </span><span class="s1">_is_key_file_encrypted(keyfile):</span>
        <span class="s0">raise </span><span class="s1">SSLError(</span><span class="s2">&quot;Client private key is encrypted, password is required&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">certfile:</span>
        <span class="s0">if </span><span class="s1">key_password </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">context.load_cert_chain(certfile</span><span class="s0">, </span><span class="s1">keyfile)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">context.load_cert_chain(certfile</span><span class="s0">, </span><span class="s1">keyfile</span><span class="s0">, </span><span class="s1">key_password)</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">context.set_alpn_protocols(ALPN_PROTOCOLS)</span>
    <span class="s0">except </span><span class="s1">NotImplementedError:  </span><span class="s3"># Defensive: in CI, we always have set_alpn_protocols</span>
        <span class="s0">pass</span>

    <span class="s1">ssl_sock = _ssl_wrap_socket_impl(sock</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">tls_in_tls</span><span class="s0">, </span><span class="s1">server_hostname)</span>
    <span class="s0">return </span><span class="s1">ssl_sock</span>


<span class="s0">def </span><span class="s1">is_ipaddress(hostname: str | bytes) -&gt; bool:</span>
    <span class="s5">&quot;&quot;&quot;Detects whether the hostname given is an IPv4 or IPv6 address. 
    Also detects IPv6 addresses with Zone IDs. 
 
    :param str hostname: Hostname to examine. 
    :return: True if the hostname is an IP address, False otherwise. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(hostname</span><span class="s0">, </span><span class="s1">bytes):</span>
        <span class="s3"># IDN A-label bytes are ASCII compatible.</span>
        <span class="s1">hostname = hostname.decode(</span><span class="s2">&quot;ascii&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">bool(_IPV4_RE.match(hostname) </span><span class="s0">or </span><span class="s1">_BRACELESS_IPV6_ADDRZ_RE.match(hostname))</span>


<span class="s0">def </span><span class="s1">_is_key_file_encrypted(key_file: str) -&gt; bool:</span>
    <span class="s5">&quot;&quot;&quot;Detects if a key file is encrypted or not.&quot;&quot;&quot;</span>
    <span class="s0">with </span><span class="s1">open(key_file) </span><span class="s0">as </span><span class="s1">f:</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">f:</span>
            <span class="s3"># Look for Proc-Type: 4,ENCRYPTED</span>
            <span class="s0">if </span><span class="s2">&quot;ENCRYPTED&quot; </span><span class="s0">in </span><span class="s1">line:</span>
                <span class="s0">return True</span>

    <span class="s0">return False</span>


<span class="s0">def </span><span class="s1">_ssl_wrap_socket_impl(</span>
    <span class="s1">sock: socket.socket</span><span class="s0">,</span>
    <span class="s1">ssl_context: ssl.SSLContext</span><span class="s0">,</span>
    <span class="s1">tls_in_tls: bool</span><span class="s0">,</span>
    <span class="s1">server_hostname: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
<span class="s1">) -&gt; ssl.SSLSocket | SSLTransportType:</span>
    <span class="s0">if </span><span class="s1">tls_in_tls:</span>
        <span class="s0">if not </span><span class="s1">SSLTransport:</span>
            <span class="s3"># Import error, ssl is not available.</span>
            <span class="s0">raise </span><span class="s1">ProxySchemeUnsupported(</span>
                <span class="s2">&quot;TLS in TLS requires support for the 'ssl' module&quot;</span>
            <span class="s1">)</span>

        <span class="s1">SSLTransport._validate_ssl_context_for_tls_in_tls(ssl_context)</span>
        <span class="s0">return </span><span class="s1">SSLTransport(sock</span><span class="s0">, </span><span class="s1">ssl_context</span><span class="s0">, </span><span class="s1">server_hostname)</span>

    <span class="s0">return </span><span class="s1">ssl_context.wrap_socket(sock</span><span class="s0">, </span><span class="s1">server_hostname=server_hostname)</span>
</pre>
</body>
</html>