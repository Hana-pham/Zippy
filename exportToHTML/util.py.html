<html>
<head>
<title>util.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
util.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -</span>
<span class="s0">#</span>
<span class="s0"># This file is part of gunicorn released under the MIT license.</span>
<span class="s0"># See the NOTICE for more information.</span>
<span class="s2">import </span><span class="s1">ast</span>
<span class="s2">import </span><span class="s1">email.utils</span>
<span class="s2">import </span><span class="s1">errno</span>
<span class="s2">import </span><span class="s1">fcntl</span>
<span class="s2">import </span><span class="s1">html</span>
<span class="s2">import </span><span class="s1">importlib</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">io</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">pwd</span>
<span class="s2">import </span><span class="s1">random</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">socket</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">textwrap</span>
<span class="s2">import </span><span class="s1">time</span>
<span class="s2">import </span><span class="s1">traceback</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">importlib.metadata </span><span class="s2">as </span><span class="s1">importlib_metadata</span>
<span class="s2">except </span><span class="s1">(ModuleNotFoundError</span><span class="s2">, </span><span class="s1">ImportError):</span>
    <span class="s2">import </span><span class="s1">importlib_metadata</span>

<span class="s2">from </span><span class="s1">gunicorn.errors </span><span class="s2">import </span><span class="s1">AppImportError</span>
<span class="s2">from </span><span class="s1">gunicorn.workers </span><span class="s2">import </span><span class="s1">SUPPORTED_WORKERS</span>
<span class="s2">import </span><span class="s1">urllib.parse</span>

<span class="s1">REDIRECT_TO = getattr(os</span><span class="s2">, </span><span class="s3">'devnull'</span><span class="s2">, </span><span class="s3">'/dev/null'</span><span class="s1">)</span>

<span class="s0"># Server and Date aren't technically hop-by-hop</span>
<span class="s0"># headers, but they are in the purview of the</span>
<span class="s0"># origin server which the WSGI spec says we should</span>
<span class="s0"># act like. So we drop them and add our own.</span>
<span class="s0">#</span>
<span class="s0"># In the future, concatenation server header values</span>
<span class="s0"># might be better, but nothing else does it and</span>
<span class="s0"># dropping them is easier.</span>
<span class="s1">hop_headers = set(</span><span class="s3">&quot;&quot;&quot; 
    connection keep-alive proxy-authenticate proxy-authorization 
    te trailers transfer-encoding upgrade 
    server date 
    &quot;&quot;&quot;</span><span class="s1">.split())</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">from </span><span class="s1">setproctitle </span><span class="s2">import </span><span class="s1">setproctitle</span>

    <span class="s2">def </span><span class="s1">_setproctitle(title):</span>
        <span class="s1">setproctitle(</span><span class="s3">&quot;gunicorn: %s&quot; </span><span class="s1">% title)</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s2">def </span><span class="s1">_setproctitle(title):</span>
        <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">load_entry_point(distribution</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, </span><span class="s1">name):</span>
    <span class="s1">dist_obj = importlib_metadata.distribution(distribution)</span>
    <span class="s1">eps = [ep </span><span class="s2">for </span><span class="s1">ep </span><span class="s2">in </span><span class="s1">dist_obj.entry_points</span>
           <span class="s2">if </span><span class="s1">ep.group == group </span><span class="s2">and </span><span class="s1">ep.name == name]</span>
    <span class="s2">if not </span><span class="s1">eps:</span>
        <span class="s2">raise </span><span class="s1">ImportError(</span><span class="s3">&quot;Entry point %r not found&quot; </span><span class="s1">% ((group</span><span class="s2">, </span><span class="s1">name)</span><span class="s2">,</span><span class="s1">))</span>
    <span class="s2">return </span><span class="s1">eps[</span><span class="s4">0</span><span class="s1">].load()</span>


<span class="s2">def </span><span class="s1">load_class(uri</span><span class="s2">, </span><span class="s1">default=</span><span class="s3">&quot;gunicorn.workers.sync.SyncWorker&quot;</span><span class="s2">,</span>
               <span class="s1">section=</span><span class="s3">&quot;gunicorn.workers&quot;</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">inspect.isclass(uri):</span>
        <span class="s2">return </span><span class="s1">uri</span>
    <span class="s2">if </span><span class="s1">uri.startswith(</span><span class="s3">&quot;egg:&quot;</span><span class="s1">):</span>
        <span class="s0"># uses entry points</span>
        <span class="s1">entry_str = uri.split(</span><span class="s3">&quot;egg:&quot;</span><span class="s1">)[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">dist</span><span class="s2">, </span><span class="s1">name = entry_str.rsplit(</span><span class="s3">&quot;#&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s1">dist = entry_str</span>
            <span class="s1">name = default</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">load_entry_point(dist</span><span class="s2">, </span><span class="s1">section</span><span class="s2">, </span><span class="s1">name)</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s1">exc = traceback.format_exc()</span>
            <span class="s1">msg = </span><span class="s3">&quot;class uri %r invalid or not found: </span><span class="s2">\n\n</span><span class="s3">[%s]&quot;</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(msg % (uri</span><span class="s2">, </span><span class="s1">exc))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">components = uri.split(</span><span class="s3">'.'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">len(components) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">while True</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">uri.startswith(</span><span class="s3">&quot;#&quot;</span><span class="s1">):</span>
                    <span class="s1">uri = uri[</span><span class="s4">1</span><span class="s1">:]</span>

                <span class="s2">if </span><span class="s1">uri </span><span class="s2">in </span><span class="s1">SUPPORTED_WORKERS:</span>
                    <span class="s1">components = SUPPORTED_WORKERS[uri].split(</span><span class="s3">&quot;.&quot;</span><span class="s1">)</span>
                    <span class="s2">break</span>

                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">load_entry_point(</span>
                        <span class="s3">&quot;gunicorn&quot;</span><span class="s2">, </span><span class="s1">section</span><span class="s2">, </span><span class="s1">uri</span>
                    <span class="s1">)</span>
                <span class="s2">except </span><span class="s1">Exception:</span>
                    <span class="s1">exc = traceback.format_exc()</span>
                    <span class="s1">msg = </span><span class="s3">&quot;class uri %r invalid or not found: </span><span class="s2">\n\n</span><span class="s3">[%s]&quot;</span>
                    <span class="s2">raise </span><span class="s1">RuntimeError(msg % (uri</span><span class="s2">, </span><span class="s1">exc))</span>

        <span class="s1">klass = components.pop(-</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">mod = importlib.import_module(</span><span class="s3">'.'</span><span class="s1">.join(components))</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s1">exc = traceback.format_exc()</span>
            <span class="s1">msg = </span><span class="s3">&quot;class uri %r invalid or not found: </span><span class="s2">\n\n</span><span class="s3">[%s]&quot;</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(msg % (uri</span><span class="s2">, </span><span class="s1">exc))</span>
        <span class="s2">return </span><span class="s1">getattr(mod</span><span class="s2">, </span><span class="s1">klass)</span>


<span class="s1">positionals = (</span>
    <span class="s1">inspect.Parameter.POSITIONAL_ONLY</span><span class="s2">,</span>
    <span class="s1">inspect.Parameter.POSITIONAL_OR_KEYWORD</span><span class="s2">,</span>
<span class="s1">)</span>


<span class="s2">def </span><span class="s1">get_arity(f):</span>
    <span class="s1">sig = inspect.signature(f)</span>
    <span class="s1">arity = </span><span class="s4">0</span>

    <span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">sig.parameters.values():</span>
        <span class="s2">if </span><span class="s1">param.kind </span><span class="s2">in </span><span class="s1">positionals:</span>
            <span class="s1">arity += </span><span class="s4">1</span>

    <span class="s2">return </span><span class="s1">arity</span>


<span class="s2">def </span><span class="s1">get_username(uid):</span>
    <span class="s5">&quot;&quot;&quot; get the username for a user id&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">pwd.getpwuid(uid).pw_name</span>


<span class="s2">def </span><span class="s1">set_owner_process(uid</span><span class="s2">, </span><span class="s1">gid</span><span class="s2">, </span><span class="s1">initgroups=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; set user and group of workers processes &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">gid:</span>
        <span class="s2">if </span><span class="s1">uid:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">username = get_username(uid)</span>
            <span class="s2">except </span><span class="s1">KeyError:</span>
                <span class="s1">initgroups = </span><span class="s2">False</span>

        <span class="s0"># versions of python &lt; 2.6.2 don't manage unsigned int for</span>
        <span class="s0"># groups like on osx or fedora</span>
        <span class="s1">gid = abs(gid) &amp; </span><span class="s4">0x7FFFFFFF</span>

        <span class="s2">if </span><span class="s1">initgroups:</span>
            <span class="s1">os.initgroups(username</span><span class="s2">, </span><span class="s1">gid)</span>
        <span class="s2">elif </span><span class="s1">gid != os.getgid():</span>
            <span class="s1">os.setgid(gid)</span>

    <span class="s2">if </span><span class="s1">uid </span><span class="s2">and </span><span class="s1">uid != os.getuid():</span>
        <span class="s1">os.setuid(uid)</span>


<span class="s2">def </span><span class="s1">chown(path</span><span class="s2">, </span><span class="s1">uid</span><span class="s2">, </span><span class="s1">gid):</span>
    <span class="s1">os.chown(path</span><span class="s2">, </span><span class="s1">uid</span><span class="s2">, </span><span class="s1">gid)</span>


<span class="s2">if </span><span class="s1">sys.platform.startswith(</span><span class="s3">&quot;win&quot;</span><span class="s1">):</span>
    <span class="s2">def </span><span class="s1">_waitfor(func</span><span class="s2">, </span><span class="s1">pathname</span><span class="s2">, </span><span class="s1">waitall=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0"># Perform the operation</span>
        <span class="s1">func(pathname)</span>
        <span class="s0"># Now setup the wait loop</span>
        <span class="s2">if </span><span class="s1">waitall:</span>
            <span class="s1">dirname = pathname</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dirname</span><span class="s2">, </span><span class="s1">name = os.path.split(pathname)</span>
            <span class="s1">dirname = dirname </span><span class="s2">or </span><span class="s3">'.'</span>
        <span class="s0"># Check for `pathname` to be removed from the filesystem.</span>
        <span class="s0"># The exponential backoff of the timeout amounts to a total</span>
        <span class="s0"># of ~1 second after which the deletion is probably an error</span>
        <span class="s0"># anyway.</span>
        <span class="s0"># Testing on a i7@4.3GHz shows that usually only 1 iteration is</span>
        <span class="s0"># required when contention occurs.</span>
        <span class="s1">timeout = </span><span class="s4">0.001</span>
        <span class="s2">while </span><span class="s1">timeout &lt; </span><span class="s4">1.0</span><span class="s1">:</span>
            <span class="s0"># Note we are only testing for the existence of the file(s) in</span>
            <span class="s0"># the contents of the directory regardless of any security or</span>
            <span class="s0"># access rights.  If we have made it this far, we have sufficient</span>
            <span class="s0"># permissions to do that much using Python's equivalent of the</span>
            <span class="s0"># Windows API FindFirstFile.</span>
            <span class="s0"># Other Windows APIs can fail or give incorrect results when</span>
            <span class="s0"># dealing with files that are pending deletion.</span>
            <span class="s1">L = os.listdir(dirname)</span>
            <span class="s2">if not </span><span class="s1">L </span><span class="s2">if </span><span class="s1">waitall </span><span class="s2">else </span><span class="s1">name </span><span class="s2">in </span><span class="s1">L:</span>
                <span class="s2">return</span>
            <span class="s0"># Increase the timeout and try again</span>
            <span class="s1">time.sleep(timeout)</span>
            <span class="s1">timeout *= </span><span class="s4">2</span>
        <span class="s1">warnings.warn(</span><span class="s3">'tests may fail, delete still pending for ' </span><span class="s1">+ pathname</span><span class="s2">,</span>
                      <span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s4">4</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_unlink(filename):</span>
        <span class="s1">_waitfor(os.unlink</span><span class="s2">, </span><span class="s1">filename)</span>
<span class="s2">else</span><span class="s1">:</span>
    <span class="s1">_unlink = os.unlink</span>


<span class="s2">def </span><span class="s1">unlink(filename):</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">_unlink(filename)</span>
    <span class="s2">except </span><span class="s1">OSError </span><span class="s2">as </span><span class="s1">error:</span>
        <span class="s0"># The filename need not exist.</span>
        <span class="s2">if </span><span class="s1">error.errno </span><span class="s2">not in </span><span class="s1">(errno.ENOENT</span><span class="s2">, </span><span class="s1">errno.ENOTDIR):</span>
            <span class="s2">raise</span>


<span class="s2">def </span><span class="s1">is_ipv6(addr):</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">socket.inet_pton(socket.AF_INET6</span><span class="s2">, </span><span class="s1">addr)</span>
    <span class="s2">except </span><span class="s1">socket.error:  </span><span class="s0"># not a valid address</span>
        <span class="s2">return False</span>
    <span class="s2">except </span><span class="s1">ValueError:  </span><span class="s0"># ipv6 not supported on this platform</span>
        <span class="s2">return False</span>
    <span class="s2">return True</span>


<span class="s2">def </span><span class="s1">parse_address(netloc</span><span class="s2">, </span><span class="s1">default_port=</span><span class="s3">'8000'</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">re.match(</span><span class="s3">r'unix:(//)?'</span><span class="s2">, </span><span class="s1">netloc):</span>
        <span class="s2">return </span><span class="s1">re.split(</span><span class="s3">r'unix:(//)?'</span><span class="s2">, </span><span class="s1">netloc)[-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">netloc.startswith(</span><span class="s3">&quot;fd://&quot;</span><span class="s1">):</span>
        <span class="s1">fd = netloc[</span><span class="s4">5</span><span class="s1">:]</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">int(fd)</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;%r is not a valid file descriptor.&quot; </span><span class="s1">% fd) </span><span class="s2">from None</span>

    <span class="s2">if </span><span class="s1">netloc.startswith(</span><span class="s3">&quot;tcp://&quot;</span><span class="s1">):</span>
        <span class="s1">netloc = netloc.split(</span><span class="s3">&quot;tcp://&quot;</span><span class="s1">)[</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">host</span><span class="s2">, </span><span class="s1">port = netloc</span><span class="s2">, </span><span class="s1">default_port</span>

    <span class="s2">if </span><span class="s3">'[' </span><span class="s2">in </span><span class="s1">netloc </span><span class="s2">and </span><span class="s3">']' </span><span class="s2">in </span><span class="s1">netloc:</span>
        <span class="s1">host = netloc.split(</span><span class="s3">']'</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s1">port = (netloc.split(</span><span class="s3">']:'</span><span class="s1">) + [default_port])[</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s2">elif </span><span class="s3">':' </span><span class="s2">in </span><span class="s1">netloc:</span>
        <span class="s1">host</span><span class="s2">, </span><span class="s1">port = (netloc.split(</span><span class="s3">':'</span><span class="s1">) + [default_port])[:</span><span class="s4">2</span><span class="s1">]</span>
    <span class="s2">elif </span><span class="s1">netloc == </span><span class="s3">&quot;&quot;</span><span class="s1">:</span>
        <span class="s1">host</span><span class="s2">, </span><span class="s1">port = </span><span class="s3">&quot;0.0.0.0&quot;</span><span class="s2">, </span><span class="s1">default_port</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">port = int(port)</span>
    <span class="s2">except </span><span class="s1">ValueError:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;%r is not a valid port number.&quot; </span><span class="s1">% port)</span>

    <span class="s2">return </span><span class="s1">host.lower()</span><span class="s2">, </span><span class="s1">port</span>


<span class="s2">def </span><span class="s1">close_on_exec(fd):</span>
    <span class="s1">flags = fcntl.fcntl(fd</span><span class="s2">, </span><span class="s1">fcntl.F_GETFD)</span>
    <span class="s1">flags |= fcntl.FD_CLOEXEC</span>
    <span class="s1">fcntl.fcntl(fd</span><span class="s2">, </span><span class="s1">fcntl.F_SETFD</span><span class="s2">, </span><span class="s1">flags)</span>


<span class="s2">def </span><span class="s1">set_non_blocking(fd):</span>
    <span class="s1">flags = fcntl.fcntl(fd</span><span class="s2">, </span><span class="s1">fcntl.F_GETFL) | os.O_NONBLOCK</span>
    <span class="s1">fcntl.fcntl(fd</span><span class="s2">, </span><span class="s1">fcntl.F_SETFL</span><span class="s2">, </span><span class="s1">flags)</span>


<span class="s2">def </span><span class="s1">close(sock):</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">sock.close()</span>
    <span class="s2">except </span><span class="s1">socket.error:</span>
        <span class="s2">pass</span>


<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">from </span><span class="s1">os </span><span class="s2">import </span><span class="s1">closerange</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s2">def </span><span class="s1">closerange(fd_low</span><span class="s2">, </span><span class="s1">fd_high):</span>
        <span class="s0"># Iterate through and close all file descriptors.</span>
        <span class="s2">for </span><span class="s1">fd </span><span class="s2">in </span><span class="s1">range(fd_low</span><span class="s2">, </span><span class="s1">fd_high):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">os.close(fd)</span>
            <span class="s2">except </span><span class="s1">OSError:  </span><span class="s0"># ERROR, fd wasn't open to begin with (ignored)</span>
                <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">write_chunk(sock</span><span class="s2">, </span><span class="s1">data):</span>
    <span class="s2">if </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s1">data = data.encode(</span><span class="s3">'utf-8'</span><span class="s1">)</span>
    <span class="s1">chunk_size = </span><span class="s3">&quot;%X</span><span class="s2">\r\n</span><span class="s3">&quot; </span><span class="s1">% len(data)</span>
    <span class="s1">chunk = </span><span class="s6">b&quot;&quot;</span><span class="s1">.join([chunk_size.encode(</span><span class="s3">'utf-8'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s6">b&quot;</span><span class="s2">\r\n</span><span class="s6">&quot;</span><span class="s1">])</span>
    <span class="s1">sock.sendall(chunk)</span>


<span class="s2">def </span><span class="s1">write(sock</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">chunked=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">chunked:</span>
        <span class="s2">return </span><span class="s1">write_chunk(sock</span><span class="s2">, </span><span class="s1">data)</span>
    <span class="s1">sock.sendall(data)</span>


<span class="s2">def </span><span class="s1">write_nonblock(sock</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">chunked=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s1">timeout = sock.gettimeout()</span>
    <span class="s2">if </span><span class="s1">timeout != </span><span class="s4">0.0</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">sock.setblocking(</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">write(sock</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">chunked)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">sock.setblocking(</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">write(sock</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">chunked)</span>


<span class="s2">def </span><span class="s1">write_error(sock</span><span class="s2">, </span><span class="s1">status_int</span><span class="s2">, </span><span class="s1">reason</span><span class="s2">, </span><span class="s1">mesg):</span>
    <span class="s1">html_error = textwrap.dedent(</span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
    </span><span class="s3">&lt;html&gt; 
      &lt;head&gt; 
        &lt;title&gt;%(reason)s&lt;/title&gt; 
      &lt;/head&gt; 
      &lt;body&gt; 
        &lt;h1&gt;&lt;p&gt;%(reason)s&lt;/p&gt;&lt;/h1&gt; 
        %(mesg)s 
      &lt;/body&gt; 
    &lt;/html&gt; 
    &quot;&quot;&quot;</span><span class="s1">) % {</span><span class="s3">&quot;reason&quot;</span><span class="s1">: reason</span><span class="s2">, </span><span class="s3">&quot;mesg&quot;</span><span class="s1">: html.escape(mesg)}</span>

    <span class="s1">http = textwrap.dedent(</span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
    </span><span class="s3">HTTP/1.1 %s %s</span><span class="s2">\r</span>
    <span class="s3">Connection: close</span><span class="s2">\r</span>
    <span class="s3">Content-Type: text/html</span><span class="s2">\r</span>
    <span class="s3">Content-Length: %d</span><span class="s2">\r</span>
    <span class="s2">\r</span>
    <span class="s3">%s&quot;&quot;&quot;</span><span class="s1">) % (str(status_int)</span><span class="s2">, </span><span class="s1">reason</span><span class="s2">, </span><span class="s1">len(html_error)</span><span class="s2">, </span><span class="s1">html_error)</span>
    <span class="s1">write_nonblock(sock</span><span class="s2">, </span><span class="s1">http.encode(</span><span class="s3">'latin1'</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">_called_with_wrong_args(f):</span>
    <span class="s5">&quot;&quot;&quot;Check whether calling a function raised a ``TypeError`` because 
    the call failed or because something in the function raised the 
    error. 
 
    :param f: The function that was called. 
    :return: ``True`` if the call failed. 
    &quot;&quot;&quot;</span>
    <span class="s1">tb = sys.exc_info()[</span><span class="s4">2</span><span class="s1">]</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">while </span><span class="s1">tb </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">tb.tb_frame.f_code </span><span class="s2">is </span><span class="s1">f.__code__:</span>
                <span class="s0"># In the function, it was called successfully.</span>
                <span class="s2">return False</span>

            <span class="s1">tb = tb.tb_next</span>

        <span class="s0"># Didn't reach the function.</span>
        <span class="s2">return True</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s0"># Delete tb to break a circular reference in Python 2.</span>
        <span class="s0"># https://docs.python.org/2/library/sys.html#sys.exc_info</span>
        <span class="s2">del </span><span class="s1">tb</span>


<span class="s2">def </span><span class="s1">import_app(module):</span>
    <span class="s1">parts = module.split(</span><span class="s3">&quot;:&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">len(parts) == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">obj = </span><span class="s3">&quot;application&quot;</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">module</span><span class="s2">, </span><span class="s1">obj = parts[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">parts[</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">mod = importlib.import_module(module)</span>
    <span class="s2">except </span><span class="s1">ImportError:</span>
        <span class="s2">if </span><span class="s1">module.endswith(</span><span class="s3">&quot;.py&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">os.path.exists(module):</span>
            <span class="s1">msg = </span><span class="s3">&quot;Failed to find application, did you mean '%s:%s'?&quot;</span>
            <span class="s2">raise </span><span class="s1">ImportError(msg % (module.rsplit(</span><span class="s3">&quot;.&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">obj))</span>
        <span class="s2">raise</span>

    <span class="s0"># Parse obj as a single expression to determine if it's a valid</span>
    <span class="s0"># attribute name or function call.</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">expression = ast.parse(obj</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;eval&quot;</span><span class="s1">).body</span>
    <span class="s2">except </span><span class="s1">SyntaxError:</span>
        <span class="s2">raise </span><span class="s1">AppImportError(</span>
            <span class="s3">&quot;Failed to parse %r as an attribute name or function call.&quot; </span><span class="s1">% obj</span>
        <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">isinstance(expression</span><span class="s2">, </span><span class="s1">ast.Name):</span>
        <span class="s1">name = expression.id</span>
        <span class="s1">args = kwargs = </span><span class="s2">None</span>
    <span class="s2">elif </span><span class="s1">isinstance(expression</span><span class="s2">, </span><span class="s1">ast.Call):</span>
        <span class="s0"># Ensure the function name is an attribute name only.</span>
        <span class="s2">if not </span><span class="s1">isinstance(expression.func</span><span class="s2">, </span><span class="s1">ast.Name):</span>
            <span class="s2">raise </span><span class="s1">AppImportError(</span><span class="s3">&quot;Function reference must be a simple name: %r&quot; </span><span class="s1">% obj)</span>

        <span class="s1">name = expression.func.id</span>

        <span class="s0"># Parse the positional and keyword arguments as literals.</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">args = [ast.literal_eval(arg) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">expression.args]</span>
            <span class="s1">kwargs = {kw.arg: ast.literal_eval(kw.value) </span><span class="s2">for </span><span class="s1">kw </span><span class="s2">in </span><span class="s1">expression.keywords}</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s0"># literal_eval gives cryptic error messages, show a generic</span>
            <span class="s0"># message with the full expression instead.</span>
            <span class="s2">raise </span><span class="s1">AppImportError(</span>
                <span class="s3">&quot;Failed to parse arguments as literal values: %r&quot; </span><span class="s1">% obj</span>
            <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">AppImportError(</span>
            <span class="s3">&quot;Failed to parse %r as an attribute name or function call.&quot; </span><span class="s1">% obj</span>
        <span class="s1">)</span>

    <span class="s1">is_debug = logging.root.level == logging.DEBUG</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">app = getattr(mod</span><span class="s2">, </span><span class="s1">name)</span>
    <span class="s2">except </span><span class="s1">AttributeError:</span>
        <span class="s2">if </span><span class="s1">is_debug:</span>
            <span class="s1">traceback.print_exception(*sys.exc_info())</span>
        <span class="s2">raise </span><span class="s1">AppImportError(</span><span class="s3">&quot;Failed to find attribute %r in %r.&quot; </span><span class="s1">% (name</span><span class="s2">, </span><span class="s1">module))</span>

    <span class="s0"># If the expression was a function call, call the retrieved object</span>
    <span class="s0"># to get the real application.</span>
    <span class="s2">if </span><span class="s1">args </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">app = app(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s0"># If the TypeError was due to bad arguments to the factory</span>
            <span class="s0"># function, show Python's nice error message without a</span>
            <span class="s0"># traceback.</span>
            <span class="s2">if </span><span class="s1">_called_with_wrong_args(app):</span>
                <span class="s2">raise </span><span class="s1">AppImportError(</span>
                    <span class="s3">&quot;&quot;</span><span class="s1">.join(traceback.format_exception_only(TypeError</span><span class="s2">, </span><span class="s1">e)).strip()</span>
                <span class="s1">)</span>

            <span class="s0"># Otherwise it was raised from within the function, show the</span>
            <span class="s0"># full traceback.</span>
            <span class="s2">raise</span>

    <span class="s2">if </span><span class="s1">app </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">AppImportError(</span><span class="s3">&quot;Failed to find application object: %r&quot; </span><span class="s1">% obj)</span>

    <span class="s2">if not </span><span class="s1">callable(app):</span>
        <span class="s2">raise </span><span class="s1">AppImportError(</span><span class="s3">&quot;Application object must be callable.&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">app</span>


<span class="s2">def </span><span class="s1">getcwd():</span>
    <span class="s0"># get current path, try to use PWD env first</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">a = os.stat(os.environ[</span><span class="s3">'PWD'</span><span class="s1">])</span>
        <span class="s1">b = os.stat(os.getcwd())</span>
        <span class="s2">if </span><span class="s1">a.st_ino == b.st_ino </span><span class="s2">and </span><span class="s1">a.st_dev == b.st_dev:</span>
            <span class="s1">cwd = os.environ[</span><span class="s3">'PWD'</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">cwd = os.getcwd()</span>
    <span class="s2">except </span><span class="s1">Exception:</span>
        <span class="s1">cwd = os.getcwd()</span>
    <span class="s2">return </span><span class="s1">cwd</span>


<span class="s2">def </span><span class="s1">http_date(timestamp=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Return the current date and time formatted for a message header.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">timestamp </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">timestamp = time.time()</span>
    <span class="s1">s = email.utils.formatdate(timestamp</span><span class="s2">, </span><span class="s1">localtime=</span><span class="s2">False, </span><span class="s1">usegmt=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">s</span>


<span class="s2">def </span><span class="s1">is_hoppish(header):</span>
    <span class="s2">return </span><span class="s1">header.lower().strip() </span><span class="s2">in </span><span class="s1">hop_headers</span>


<span class="s2">def </span><span class="s1">daemonize(enable_stdio_inheritance=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;\ 
    Standard daemonization of a process. 
    http://www.faqs.org/faqs/unix-faq/programmer/faq/ section 1.7 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s3">'GUNICORN_FD' </span><span class="s2">not in </span><span class="s1">os.environ:</span>
        <span class="s2">if </span><span class="s1">os.fork():</span>
            <span class="s1">os._exit(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">os.setsid()</span>

        <span class="s2">if </span><span class="s1">os.fork():</span>
            <span class="s1">os._exit(</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">os.umask(</span><span class="s4">0o22</span><span class="s1">)</span>

        <span class="s0"># In both the following any file descriptors above stdin</span>
        <span class="s0"># stdout and stderr are left untouched. The inheritance</span>
        <span class="s0"># option simply allows one to have output go to a file</span>
        <span class="s0"># specified by way of shell redirection when not wanting</span>
        <span class="s0"># to use --error-log option.</span>

        <span class="s2">if not </span><span class="s1">enable_stdio_inheritance:</span>
            <span class="s0"># Remap all of stdin, stdout and stderr on to</span>
            <span class="s0"># /dev/null. The expectation is that users have</span>
            <span class="s0"># specified the --error-log option.</span>

            <span class="s1">closerange(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>

            <span class="s1">fd_null = os.open(REDIRECT_TO</span><span class="s2">, </span><span class="s1">os.O_RDWR)</span>
            <span class="s0"># PEP 446, make fd for /dev/null inheritable</span>
            <span class="s1">os.set_inheritable(fd_null</span><span class="s2">, True</span><span class="s1">)</span>

            <span class="s0"># expect fd_null to be always 0 here, but in-case not ...</span>
            <span class="s2">if </span><span class="s1">fd_null != </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">os.dup2(fd_null</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

            <span class="s1">os.dup2(fd_null</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">os.dup2(fd_null</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">fd_null = os.open(REDIRECT_TO</span><span class="s2">, </span><span class="s1">os.O_RDWR)</span>

            <span class="s0"># Always redirect stdin to /dev/null as we would</span>
            <span class="s0"># never expect to need to read interactive input.</span>

            <span class="s2">if </span><span class="s1">fd_null != </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">os.close(</span><span class="s4">0</span><span class="s1">)</span>
                <span class="s1">os.dup2(fd_null</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

            <span class="s0"># If stdout and stderr are still connected to</span>
            <span class="s0"># their original file descriptors we check to see</span>
            <span class="s0"># if they are associated with terminal devices.</span>
            <span class="s0"># When they are we map them to /dev/null so that</span>
            <span class="s0"># are still detached from any controlling terminal</span>
            <span class="s0"># properly. If not we preserve them as they are.</span>
            <span class="s0">#</span>
            <span class="s0"># If stdin and stdout were not hooked up to the</span>
            <span class="s0"># original file descriptors, then all bets are</span>
            <span class="s0"># off and all we can really do is leave them as</span>
            <span class="s0"># they were.</span>
            <span class="s0">#</span>
            <span class="s0"># This will allow 'gunicorn ... &gt; output.log 2&gt;&amp;1'</span>
            <span class="s0"># to work with stdout/stderr going to the file</span>
            <span class="s0"># as expected.</span>
            <span class="s0">#</span>
            <span class="s0"># Note that if using --error-log option, the log</span>
            <span class="s0"># file specified through shell redirection will</span>
            <span class="s0"># only be used up until the log file specified</span>
            <span class="s0"># by the option takes over. As it replaces stdout</span>
            <span class="s0"># and stderr at the file descriptor level, then</span>
            <span class="s0"># anything using stdout or stderr, including having</span>
            <span class="s0"># cached a reference to them, will still work.</span>

            <span class="s2">def </span><span class="s1">redirect(stream</span><span class="s2">, </span><span class="s1">fd_expect):</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">fd = stream.fileno()</span>
                    <span class="s2">if </span><span class="s1">fd == fd_expect </span><span class="s2">and </span><span class="s1">stream.isatty():</span>
                        <span class="s1">os.close(fd)</span>
                        <span class="s1">os.dup2(fd_null</span><span class="s2">, </span><span class="s1">fd)</span>
                <span class="s2">except </span><span class="s1">AttributeError:</span>
                    <span class="s2">pass</span>

            <span class="s1">redirect(sys.stdout</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">redirect(sys.stderr</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">seed():</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">random.seed(os.urandom(</span><span class="s4">64</span><span class="s1">))</span>
    <span class="s2">except </span><span class="s1">NotImplementedError:</span>
        <span class="s1">random.seed(</span><span class="s3">'%s.%s' </span><span class="s1">% (time.time()</span><span class="s2">, </span><span class="s1">os.getpid()))</span>


<span class="s2">def </span><span class="s1">check_is_writable(path):</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">with </span><span class="s1">open(path</span><span class="s2">, </span><span class="s3">'a'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
            <span class="s1">f.close()</span>
    <span class="s2">except </span><span class="s1">IOError </span><span class="s2">as </span><span class="s1">e:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;Error: '%s' isn't writable [%r]&quot; </span><span class="s1">% (path</span><span class="s2">, </span><span class="s1">e))</span>


<span class="s2">def </span><span class="s1">to_bytestring(value</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s3">&quot;utf8&quot;</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Converts a string argument to a byte string&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">bytes):</span>
        <span class="s2">return </span><span class="s1">value</span>
    <span class="s2">if not </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">'%r is not a string' </span><span class="s1">% value)</span>

    <span class="s2">return </span><span class="s1">value.encode(encoding)</span>


<span class="s2">def </span><span class="s1">has_fileno(obj):</span>
    <span class="s2">if not </span><span class="s1">hasattr(obj</span><span class="s2">, </span><span class="s3">&quot;fileno&quot;</span><span class="s1">):</span>
        <span class="s2">return False</span>

    <span class="s0"># check BytesIO case and maybe others</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">obj.fileno()</span>
    <span class="s2">except </span><span class="s1">(AttributeError</span><span class="s2">, </span><span class="s1">IOError</span><span class="s2">, </span><span class="s1">io.UnsupportedOperation):</span>
        <span class="s2">return False</span>

    <span class="s2">return True</span>


<span class="s2">def </span><span class="s1">warn(msg):</span>
    <span class="s1">print(</span><span class="s3">&quot;!!!&quot;</span><span class="s2">, </span><span class="s1">file=sys.stderr)</span>

    <span class="s1">lines = msg.splitlines()</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">line </span><span class="s2">in </span><span class="s1">enumerate(lines):</span>
        <span class="s2">if </span><span class="s1">i == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">line = </span><span class="s3">&quot;WARNING: %s&quot; </span><span class="s1">% line</span>
        <span class="s1">print(</span><span class="s3">&quot;!!! %s&quot; </span><span class="s1">% line</span><span class="s2">, </span><span class="s1">file=sys.stderr)</span>

    <span class="s1">print(</span><span class="s3">&quot;!!!</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">file=sys.stderr)</span>
    <span class="s1">sys.stderr.flush()</span>


<span class="s2">def </span><span class="s1">make_fail_app(msg):</span>
    <span class="s1">msg = to_bytestring(msg)</span>

    <span class="s2">def </span><span class="s1">app(environ</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">start_response(</span><span class="s3">&quot;500 Internal Server Error&quot;</span><span class="s2">, </span><span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;Content-Type&quot;</span><span class="s2">, </span><span class="s3">&quot;text/plain&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;Content-Length&quot;</span><span class="s2">, </span><span class="s1">str(len(msg)))</span>
        <span class="s1">])</span>
        <span class="s2">return </span><span class="s1">[msg]</span>

    <span class="s2">return </span><span class="s1">app</span>


<span class="s2">def </span><span class="s1">split_request_uri(uri):</span>
    <span class="s2">if </span><span class="s1">uri.startswith(</span><span class="s3">&quot;//&quot;</span><span class="s1">):</span>
        <span class="s0"># When the path starts with //, urlsplit considers it as a</span>
        <span class="s0"># relative uri while the RFC says we should consider it as abs_path</span>
        <span class="s0"># http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2</span>
        <span class="s0"># We use temporary dot prefix to workaround this behaviour</span>
        <span class="s1">parts = urllib.parse.urlsplit(</span><span class="s3">&quot;.&quot; </span><span class="s1">+ uri)</span>
        <span class="s2">return </span><span class="s1">parts._replace(path=parts.path[</span><span class="s4">1</span><span class="s1">:])</span>

    <span class="s2">return </span><span class="s1">urllib.parse.urlsplit(uri)</span>


<span class="s0"># From six.reraise</span>
<span class="s2">def </span><span class="s1">reraise(tp</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">tb=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">value </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">value = tp()</span>
        <span class="s2">if </span><span class="s1">value.__traceback__ </span><span class="s2">is not </span><span class="s1">tb:</span>
            <span class="s2">raise </span><span class="s1">value.with_traceback(tb)</span>
        <span class="s2">raise </span><span class="s1">value</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s1">value = </span><span class="s2">None</span>
        <span class="s1">tb = </span><span class="s2">None</span>


<span class="s2">def </span><span class="s1">bytes_to_str(b):</span>
    <span class="s2">if </span><span class="s1">isinstance(b</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">return </span><span class="s1">b</span>
    <span class="s2">return </span><span class="s1">str(b</span><span class="s2">, </span><span class="s3">'latin1'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">unquote_to_wsgi_str(string):</span>
    <span class="s2">return </span><span class="s1">urllib.parse.unquote_to_bytes(string).decode(</span><span class="s3">'latin-1'</span><span class="s1">)</span>
</pre>
</body>
</html>