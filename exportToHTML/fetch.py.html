<html>
<head>
<title>fetch.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
fetch.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Support for streaming http requests in emscripten. 
 
A few caveats - 
 
Firstly, you can't do streaming http in the main UI thread, because atomics.wait isn't allowed. 
Streaming only works if you're running pyodide in a web worker. 
 
Secondly, this uses an extra web worker and SharedArrayBuffer to do the asynchronous fetch 
operation, so it requires that you have crossOriginIsolation enabled, by serving over https 
(or from localhost) with the two headers below set: 
 
    Cross-Origin-Opener-Policy: same-origin 
    Cross-Origin-Embedder-Policy: require-corp 
 
You can tell if cross origin isolation is successfully enabled by looking at the global crossOriginIsolated variable in 
javascript console. If it isn't, streaming requests will fallback to XMLHttpRequest, i.e. getting the whole 
request into a buffer and then returning it. it shows a warning in the javascript console in this case. 
 
Finally, the webworker which does the streaming fetch is created on initial import, but will only be started once 
control is returned to javascript. Call `await wait_for_streaming_ready()` to wait for streaming fetch. 
 
NB: in this code, there are a lot of javascript objects. They are named js_* 
to make it clear what type of object they are. 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">io</span>
<span class="s2">import </span><span class="s1">json</span>
<span class="s2">from </span><span class="s1">email.parser </span><span class="s2">import </span><span class="s1">Parser</span>
<span class="s2">from </span><span class="s1">importlib.resources </span><span class="s2">import </span><span class="s1">files</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span><span class="s2">, </span><span class="s1">Any</span>

<span class="s2">import </span><span class="s1">js  </span><span class="s3"># type: ignore[import-not-found]</span>
<span class="s2">from </span><span class="s1">pyodide.ffi </span><span class="s2">import </span><span class="s1">(  </span><span class="s3"># type: ignore[import-not-found]</span>
    <span class="s1">JsArray</span><span class="s2">,</span>
    <span class="s1">JsException</span><span class="s2">,</span>
    <span class="s1">JsProxy</span><span class="s2">,</span>
    <span class="s1">to_js</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">typing_extensions </span><span class="s2">import </span><span class="s1">Buffer</span>

<span class="s2">from </span><span class="s1">.request </span><span class="s2">import </span><span class="s1">EmscriptenRequest</span>
<span class="s2">from </span><span class="s1">.response </span><span class="s2">import </span><span class="s1">EmscriptenResponse</span>

<span class="s4">&quot;&quot;&quot; 
There are some headers that trigger unintended CORS preflight requests. 
See also https://github.com/koenvo/pyodide-http/issues/22 
&quot;&quot;&quot;</span>
<span class="s1">HEADERS_TO_IGNORE = (</span><span class="s4">&quot;user-agent&quot;</span><span class="s2">,</span><span class="s1">)</span>

<span class="s1">SUCCESS_HEADER = -</span><span class="s5">1</span>
<span class="s1">SUCCESS_EOF = -</span><span class="s5">2</span>
<span class="s1">ERROR_TIMEOUT = -</span><span class="s5">3</span>
<span class="s1">ERROR_EXCEPTION = -</span><span class="s5">4</span>

<span class="s1">_STREAMING_WORKER_CODE = (</span>
    <span class="s1">files(__package__)</span>
    <span class="s1">.joinpath(</span><span class="s4">&quot;emscripten_fetch_worker.js&quot;</span><span class="s1">)</span>
    <span class="s1">.read_text(encoding=</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">)</span>
<span class="s1">)</span>


<span class="s2">class </span><span class="s1">_RequestError(Exception):</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">message: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">request: EmscriptenRequest | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">response: EmscriptenResponse | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">self.request = request</span>
        <span class="s1">self.response = response</span>
        <span class="s1">self.message = message</span>
        <span class="s1">super().__init__(self.message)</span>


<span class="s2">class </span><span class="s1">_StreamingError(_RequestError):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">_TimeoutError(_RequestError):</span>
    <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">_obj_from_dict(dict_val: dict[str</span><span class="s2">, </span><span class="s1">Any]) -&gt; JsProxy:</span>
    <span class="s2">return </span><span class="s1">to_js(dict_val</span><span class="s2">, </span><span class="s1">dict_converter=js.Object.fromEntries)</span>


<span class="s2">class </span><span class="s1">_ReadStream(io.RawIOBase):</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">int_buffer: JsArray</span><span class="s2">,</span>
        <span class="s1">byte_buffer: JsArray</span><span class="s2">,</span>
        <span class="s1">timeout: float</span><span class="s2">,</span>
        <span class="s1">worker: JsProxy</span><span class="s2">,</span>
        <span class="s1">connection_id: int</span><span class="s2">,</span>
        <span class="s1">request: EmscriptenRequest</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">self.int_buffer = int_buffer</span>
        <span class="s1">self.byte_buffer = byte_buffer</span>
        <span class="s1">self.read_pos = </span><span class="s5">0</span>
        <span class="s1">self.read_len = </span><span class="s5">0</span>
        <span class="s1">self.connection_id = connection_id</span>
        <span class="s1">self.worker = worker</span>
        <span class="s1">self.timeout = int(</span><span class="s5">1000 </span><span class="s1">* timeout) </span><span class="s2">if </span><span class="s1">timeout &gt; </span><span class="s5">0 </span><span class="s2">else None</span>
        <span class="s1">self.is_live = </span><span class="s2">True</span>
        <span class="s1">self._is_closed = </span><span class="s2">False</span>
        <span class="s1">self.request: EmscriptenRequest | </span><span class="s2">None </span><span class="s1">= request</span>

    <span class="s2">def </span><span class="s1">__del__(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.close()</span>

    <span class="s3"># this is compatible with _base_connection</span>
    <span class="s2">def </span><span class="s1">is_closed(self) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">self._is_closed</span>

    <span class="s3"># for compatibility with RawIOBase</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">closed(self) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">self.is_closed()</span>

    <span class="s2">def </span><span class="s1">close(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">self.is_closed():</span>
            <span class="s1">self.read_len = </span><span class="s5">0</span>
            <span class="s1">self.read_pos = </span><span class="s5">0</span>
            <span class="s1">self.int_buffer = </span><span class="s2">None</span>
            <span class="s1">self.byte_buffer = </span><span class="s2">None</span>
            <span class="s1">self._is_closed = </span><span class="s2">True</span>
            <span class="s1">self.request = </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s1">self.is_live:</span>
                <span class="s1">self.worker.postMessage(_obj_from_dict({</span><span class="s4">&quot;close&quot;</span><span class="s1">: self.connection_id}))</span>
                <span class="s1">self.is_live = </span><span class="s2">False</span>
            <span class="s1">super().close()</span>

    <span class="s2">def </span><span class="s1">readable(self) -&gt; bool:</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">writable(self) -&gt; bool:</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">seekable(self) -&gt; bool:</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">readinto(self</span><span class="s2">, </span><span class="s1">byte_obj: Buffer) -&gt; int:</span>
        <span class="s2">if not </span><span class="s1">self.int_buffer:</span>
            <span class="s2">raise </span><span class="s1">_StreamingError(</span>
                <span class="s4">&quot;No buffer for stream in _ReadStream.readinto&quot;</span><span class="s2">,</span>
                <span class="s1">request=self.request</span><span class="s2">,</span>
                <span class="s1">response=</span><span class="s2">None,</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.read_len == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3"># wait for the worker to send something</span>
            <span class="s1">js.Atomics.store(self.int_buffer</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">ERROR_TIMEOUT)</span>
            <span class="s1">self.worker.postMessage(_obj_from_dict({</span><span class="s4">&quot;getMore&quot;</span><span class="s1">: self.connection_id}))</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">js.Atomics.wait(self.int_buffer</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">ERROR_TIMEOUT</span><span class="s2">, </span><span class="s1">self.timeout)</span>
                <span class="s1">== </span><span class="s4">&quot;timed-out&quot;</span>
            <span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">_TimeoutError</span>
            <span class="s1">data_len = self.int_buffer[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">data_len &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">self.read_len = data_len</span>
                <span class="s1">self.read_pos = </span><span class="s5">0</span>
            <span class="s2">elif </span><span class="s1">data_len == ERROR_EXCEPTION:</span>
                <span class="s1">string_len = self.int_buffer[</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s3"># decode the error string</span>
                <span class="s1">js_decoder = js.TextDecoder.new()</span>
                <span class="s1">json_str = js_decoder.decode(self.byte_buffer.slice(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">string_len))</span>
                <span class="s2">raise </span><span class="s1">_StreamingError(</span>
                    <span class="s4">f&quot;Exception thrown in fetch: </span><span class="s2">{</span><span class="s1">json_str</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s2">,</span>
                    <span class="s1">request=self.request</span><span class="s2">,</span>
                    <span class="s1">response=</span><span class="s2">None,</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s3"># EOF, free the buffers and return zero</span>
                <span class="s3"># and free the request</span>
                <span class="s1">self.is_live = </span><span class="s2">False</span>
                <span class="s1">self.close()</span>
                <span class="s2">return </span><span class="s5">0</span>
        <span class="s3"># copy from int32array to python bytes</span>
        <span class="s1">ret_length = min(self.read_len</span><span class="s2">, </span><span class="s1">len(memoryview(byte_obj)))</span>
        <span class="s1">subarray = self.byte_buffer.subarray(</span>
            <span class="s1">self.read_pos</span><span class="s2">, </span><span class="s1">self.read_pos + ret_length</span>
        <span class="s1">).to_py()</span>
        <span class="s1">memoryview(byte_obj)[</span><span class="s5">0</span><span class="s1">:ret_length] = subarray</span>
        <span class="s1">self.read_len -= ret_length</span>
        <span class="s1">self.read_pos += ret_length</span>
        <span class="s2">return </span><span class="s1">ret_length</span>


<span class="s2">class </span><span class="s1">_StreamingFetcher:</span>
    <span class="s2">def </span><span class="s1">__init__(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3"># make web-worker and data buffer on startup</span>
        <span class="s1">self.streaming_ready = </span><span class="s2">False</span>

        <span class="s1">js_data_blob = js.Blob.new(</span>
            <span class="s1">[_STREAMING_WORKER_CODE]</span><span class="s2">, </span><span class="s1">_obj_from_dict({</span><span class="s4">&quot;type&quot;</span><span class="s1">: </span><span class="s4">&quot;application/javascript&quot;</span><span class="s1">})</span>
        <span class="s1">)</span>

        <span class="s2">def </span><span class="s1">promise_resolver(js_resolve_fn: JsProxy</span><span class="s2">, </span><span class="s1">js_reject_fn: JsProxy) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
            <span class="s2">def </span><span class="s1">onMsg(e: JsProxy) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
                <span class="s1">self.streaming_ready = </span><span class="s2">True</span>
                <span class="s1">js_resolve_fn(e)</span>

            <span class="s2">def </span><span class="s1">onErr(e: JsProxy) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
                <span class="s1">js_reject_fn(e)  </span><span class="s3"># Defensive: never happens in ci</span>

            <span class="s1">self.js_worker.onmessage = onMsg</span>
            <span class="s1">self.js_worker.onerror = onErr</span>

        <span class="s1">js_data_url = js.URL.createObjectURL(js_data_blob)</span>
        <span class="s1">self.js_worker = js.globalThis.Worker.new(js_data_url)</span>
        <span class="s1">self.js_worker_ready_promise = js.globalThis.Promise.new(promise_resolver)</span>

    <span class="s2">def </span><span class="s1">send(self</span><span class="s2">, </span><span class="s1">request: EmscriptenRequest) -&gt; EmscriptenResponse:</span>
        <span class="s1">headers = {</span>
            <span class="s1">k: v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">request.headers.items() </span><span class="s2">if </span><span class="s1">k </span><span class="s2">not in </span><span class="s1">HEADERS_TO_IGNORE</span>
        <span class="s1">}</span>

        <span class="s1">body = request.body</span>
        <span class="s1">fetch_data = {</span><span class="s4">&quot;headers&quot;</span><span class="s1">: headers</span><span class="s2">, </span><span class="s4">&quot;body&quot;</span><span class="s1">: to_js(body)</span><span class="s2">, </span><span class="s4">&quot;method&quot;</span><span class="s1">: request.method}</span>
        <span class="s3"># start the request off in the worker</span>
        <span class="s1">timeout = int(</span><span class="s5">1000 </span><span class="s1">* request.timeout) </span><span class="s2">if </span><span class="s1">request.timeout &gt; </span><span class="s5">0 </span><span class="s2">else None</span>
        <span class="s1">js_shared_buffer = js.SharedArrayBuffer.new(</span><span class="s5">1048576</span><span class="s1">)</span>
        <span class="s1">js_int_buffer = js.Int32Array.new(js_shared_buffer)</span>
        <span class="s1">js_byte_buffer = js.Uint8Array.new(js_shared_buffer</span><span class="s2">, </span><span class="s5">8</span><span class="s1">)</span>

        <span class="s1">js.Atomics.store(js_int_buffer</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">ERROR_TIMEOUT)</span>
        <span class="s1">js.Atomics.notify(js_int_buffer</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">js_absolute_url = js.URL.new(request.url</span><span class="s2">, </span><span class="s1">js.location).href</span>
        <span class="s1">self.js_worker.postMessage(</span>
            <span class="s1">_obj_from_dict(</span>
                <span class="s1">{</span>
                    <span class="s4">&quot;buffer&quot;</span><span class="s1">: js_shared_buffer</span><span class="s2">,</span>
                    <span class="s4">&quot;url&quot;</span><span class="s1">: js_absolute_url</span><span class="s2">,</span>
                    <span class="s4">&quot;fetchParams&quot;</span><span class="s1">: fetch_data</span><span class="s2">,</span>
                <span class="s1">}</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s3"># wait for the worker to send something</span>
        <span class="s1">js.Atomics.wait(js_int_buffer</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">ERROR_TIMEOUT</span><span class="s2">, </span><span class="s1">timeout)</span>
        <span class="s2">if </span><span class="s1">js_int_buffer[</span><span class="s5">0</span><span class="s1">] == ERROR_TIMEOUT:</span>
            <span class="s2">raise </span><span class="s1">_TimeoutError(</span>
                <span class="s4">&quot;Timeout connecting to streaming request&quot;</span><span class="s2">,</span>
                <span class="s1">request=request</span><span class="s2">,</span>
                <span class="s1">response=</span><span class="s2">None,</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">js_int_buffer[</span><span class="s5">0</span><span class="s1">] == SUCCESS_HEADER:</span>
            <span class="s3"># got response</span>
            <span class="s3"># header length is in second int of intBuffer</span>
            <span class="s1">string_len = js_int_buffer[</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s3"># decode the rest to a JSON string</span>
            <span class="s1">js_decoder = js.TextDecoder.new()</span>
            <span class="s3"># this does a copy (the slice) because decode can't work on shared array</span>
            <span class="s3"># for some silly reason</span>
            <span class="s1">json_str = js_decoder.decode(js_byte_buffer.slice(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">string_len))</span>
            <span class="s3"># get it as an object</span>
            <span class="s1">response_obj = json.loads(json_str)</span>
            <span class="s2">return </span><span class="s1">EmscriptenResponse(</span>
                <span class="s1">request=request</span><span class="s2">,</span>
                <span class="s1">status_code=response_obj[</span><span class="s4">&quot;status&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">headers=response_obj[</span><span class="s4">&quot;headers&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">body=_ReadStream(</span>
                    <span class="s1">js_int_buffer</span><span class="s2">,</span>
                    <span class="s1">js_byte_buffer</span><span class="s2">,</span>
                    <span class="s1">request.timeout</span><span class="s2">,</span>
                    <span class="s1">self.js_worker</span><span class="s2">,</span>
                    <span class="s1">response_obj[</span><span class="s4">&quot;connectionID&quot;</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">request</span><span class="s2">,</span>
                <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">js_int_buffer[</span><span class="s5">0</span><span class="s1">] == ERROR_EXCEPTION:</span>
            <span class="s1">string_len = js_int_buffer[</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s3"># decode the error string</span>
            <span class="s1">js_decoder = js.TextDecoder.new()</span>
            <span class="s1">json_str = js_decoder.decode(js_byte_buffer.slice(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">string_len))</span>
            <span class="s2">raise </span><span class="s1">_StreamingError(</span>
                <span class="s4">f&quot;Exception thrown in fetch: </span><span class="s2">{</span><span class="s1">json_str</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s2">, </span><span class="s1">request=request</span><span class="s2">, </span><span class="s1">response=</span><span class="s2">None</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">_StreamingError(</span>
                <span class="s4">f&quot;Unknown status from worker in fetch: </span><span class="s2">{</span><span class="s1">js_int_buffer[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s2">,</span>
                <span class="s1">request=request</span><span class="s2">,</span>
                <span class="s1">response=</span><span class="s2">None,</span>
            <span class="s1">)</span>


<span class="s3"># check if we are in a worker or not</span>
<span class="s2">def </span><span class="s1">is_in_browser_main_thread() -&gt; bool:</span>
    <span class="s2">return </span><span class="s1">hasattr(js</span><span class="s2">, </span><span class="s4">&quot;window&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">hasattr(js</span><span class="s2">, </span><span class="s4">&quot;self&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">js.self == js.window</span>


<span class="s2">def </span><span class="s1">is_cross_origin_isolated() -&gt; bool:</span>
    <span class="s2">return </span><span class="s1">hasattr(js</span><span class="s2">, </span><span class="s4">&quot;crossOriginIsolated&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">js.crossOriginIsolated</span>


<span class="s2">def </span><span class="s1">is_in_node() -&gt; bool:</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">hasattr(js</span><span class="s2">, </span><span class="s4">&quot;process&quot;</span><span class="s1">)</span>
        <span class="s2">and </span><span class="s1">hasattr(js.process</span><span class="s2">, </span><span class="s4">&quot;release&quot;</span><span class="s1">)</span>
        <span class="s2">and </span><span class="s1">hasattr(js.process.release</span><span class="s2">, </span><span class="s4">&quot;name&quot;</span><span class="s1">)</span>
        <span class="s2">and </span><span class="s1">js.process.release.name == </span><span class="s4">&quot;node&quot;</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">is_worker_available() -&gt; bool:</span>
    <span class="s2">return </span><span class="s1">hasattr(js</span><span class="s2">, </span><span class="s4">&quot;Worker&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">hasattr(js</span><span class="s2">, </span><span class="s4">&quot;Blob&quot;</span><span class="s1">)</span>


<span class="s1">_fetcher: _StreamingFetcher | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span>

<span class="s2">if </span><span class="s1">is_worker_available() </span><span class="s2">and </span><span class="s1">(</span>
    <span class="s1">(is_cross_origin_isolated() </span><span class="s2">and not </span><span class="s1">is_in_browser_main_thread())</span>
    <span class="s2">and </span><span class="s1">(</span><span class="s2">not </span><span class="s1">is_in_node())</span>
<span class="s1">):</span>
    <span class="s1">_fetcher = _StreamingFetcher()</span>
<span class="s2">else</span><span class="s1">:</span>
    <span class="s1">_fetcher = </span><span class="s2">None</span>


<span class="s2">def </span><span class="s1">send_streaming_request(request: EmscriptenRequest) -&gt; EmscriptenResponse | </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s2">if </span><span class="s1">_fetcher </span><span class="s2">and </span><span class="s1">streaming_ready():</span>
        <span class="s2">return </span><span class="s1">_fetcher.send(request)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">_show_streaming_warning()</span>
        <span class="s2">return None</span>


<span class="s1">_SHOWN_TIMEOUT_WARNING = </span><span class="s2">False</span>


<span class="s2">def </span><span class="s1">_show_timeout_warning() -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s2">global </span><span class="s1">_SHOWN_TIMEOUT_WARNING</span>
    <span class="s2">if not </span><span class="s1">_SHOWN_TIMEOUT_WARNING:</span>
        <span class="s1">_SHOWN_TIMEOUT_WARNING = </span><span class="s2">True</span>
        <span class="s1">message = </span><span class="s4">&quot;Warning: Timeout is not available on main browser thread&quot;</span>
        <span class="s1">js.console.warn(message)</span>


<span class="s1">_SHOWN_STREAMING_WARNING = </span><span class="s2">False</span>


<span class="s2">def </span><span class="s1">_show_streaming_warning() -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s2">global </span><span class="s1">_SHOWN_STREAMING_WARNING</span>
    <span class="s2">if not </span><span class="s1">_SHOWN_STREAMING_WARNING:</span>
        <span class="s1">_SHOWN_STREAMING_WARNING = </span><span class="s2">True</span>
        <span class="s1">message = </span><span class="s4">&quot;Can't stream HTTP requests because: </span><span class="s2">\n</span><span class="s4">&quot;</span>
        <span class="s2">if not </span><span class="s1">is_cross_origin_isolated():</span>
            <span class="s1">message += </span><span class="s4">&quot;  Page is not cross-origin isolated</span><span class="s2">\n</span><span class="s4">&quot;</span>
        <span class="s2">if </span><span class="s1">is_in_browser_main_thread():</span>
            <span class="s1">message += </span><span class="s4">&quot;  Python is running in main browser thread</span><span class="s2">\n</span><span class="s4">&quot;</span>
        <span class="s2">if not </span><span class="s1">is_worker_available():</span>
            <span class="s1">message += </span><span class="s4">&quot; Worker or Blob classes are not available in this environment.&quot;  </span><span class="s3"># Defensive: this is always False in browsers that we test in</span>
        <span class="s2">if </span><span class="s1">streaming_ready() </span><span class="s2">is False</span><span class="s1">:</span>
            <span class="s1">message += </span><span class="s4">&quot;&quot;&quot; Streaming fetch worker isn't ready. If you want to be sure that streaming fetch 
is working, you need to call: 'await urllib3.contrib.emscripten.fetch.wait_for_streaming_ready()`&quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">js </span><span class="s2">import </span><span class="s1">console</span>

        <span class="s1">console.warn(message)</span>


<span class="s2">def </span><span class="s1">send_request(request: EmscriptenRequest) -&gt; EmscriptenResponse:</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">js_xhr = js.XMLHttpRequest.new()</span>

        <span class="s2">if not </span><span class="s1">is_in_browser_main_thread():</span>
            <span class="s1">js_xhr.responseType = </span><span class="s4">&quot;arraybuffer&quot;</span>
            <span class="s2">if </span><span class="s1">request.timeout:</span>
                <span class="s1">js_xhr.timeout = int(request.timeout * </span><span class="s5">1000</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">js_xhr.overrideMimeType(</span><span class="s4">&quot;text/plain; charset=ISO-8859-15&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">request.timeout:</span>
                <span class="s3"># timeout isn't available on the main thread - show a warning in console</span>
                <span class="s3"># if it is set</span>
                <span class="s1">_show_timeout_warning()</span>

        <span class="s1">js_xhr.open(request.method</span><span class="s2">, </span><span class="s1">request.url</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">request.headers.items():</span>
            <span class="s2">if </span><span class="s1">name.lower() </span><span class="s2">not in </span><span class="s1">HEADERS_TO_IGNORE:</span>
                <span class="s1">js_xhr.setRequestHeader(name</span><span class="s2">, </span><span class="s1">value)</span>

        <span class="s1">js_xhr.send(to_js(request.body))</span>

        <span class="s1">headers = dict(Parser().parsestr(js_xhr.getAllResponseHeaders()))</span>

        <span class="s2">if not </span><span class="s1">is_in_browser_main_thread():</span>
            <span class="s1">body = js_xhr.response.to_py().tobytes()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">body = js_xhr.response.encode(</span><span class="s4">&quot;ISO-8859-15&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">EmscriptenResponse(</span>
            <span class="s1">status_code=js_xhr.status</span><span class="s2">, </span><span class="s1">headers=headers</span><span class="s2">, </span><span class="s1">body=body</span><span class="s2">, </span><span class="s1">request=request</span>
        <span class="s1">)</span>
    <span class="s2">except </span><span class="s1">JsException </span><span class="s2">as </span><span class="s1">err:</span>
        <span class="s2">if </span><span class="s1">err.name == </span><span class="s4">&quot;TimeoutError&quot;</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">_TimeoutError(err.message</span><span class="s2">, </span><span class="s1">request=request)</span>
        <span class="s2">elif </span><span class="s1">err.name == </span><span class="s4">&quot;NetworkError&quot;</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">_RequestError(err.message</span><span class="s2">, </span><span class="s1">request=request)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># general http error</span>
            <span class="s2">raise </span><span class="s1">_RequestError(err.message</span><span class="s2">, </span><span class="s1">request=request)</span>


<span class="s2">def </span><span class="s1">streaming_ready() -&gt; bool | </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s2">if </span><span class="s1">_fetcher:</span>
        <span class="s2">return </span><span class="s1">_fetcher.streaming_ready</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return None  </span><span class="s3"># no fetcher, return None to signify that</span>


<span class="s2">async def </span><span class="s1">wait_for_streaming_ready() -&gt; bool:</span>
    <span class="s2">if </span><span class="s1">_fetcher:</span>
        <span class="s2">await </span><span class="s1">_fetcher.js_worker_ready_promise</span>
        <span class="s2">return True</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return False</span>
</pre>
</body>
</html>